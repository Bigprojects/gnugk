<!doctype linuxdoc system>
<!-- This is the User Manual for OpenH323 Gatekeeper - The GNU Gatekeeper -->

<article>
<!-- Title information -->
<title>OpenH323 Gatekeeper - The GNU Gatekeeper
<author>Maintainer of this manual:
<htmlurl url="http://www.willamowius.de/" name="Jan Willamowius">
<tt><htmlurl url="mailto:jan@willamowius.de" name="&lt;jan@willamowius.de&gt;"></tt>

<abstract>
This is the User Manual
how to compile, install, configure and monitor
OpenH323 Gatekeeper - The GNU Gatekeeper.
</abstract>

<!-- Table of contents -->
<toc>

<!-- Begin of document -->

<!----------          Next Section          ---------->
<sect>Introduction
<p>
<!--
This manual is also available in Portuguese and Traditional Chinese.
The English version is the master document and will get updated first.
-->
<sect1>About
<p>
<bf>
<url url="http://www.gnugk.org/" name="OpenH323 Gatekeeper - The GNU Gatekeeper">
</bf>
is an open-source project that implements an H.323 gatekeeper.
A gatekeeper provides call control services to the H.323 endpoints.
It is an integral part of most usefull internet telephony
installations that are based on the H.323 standard.

According to Recommendation H.323, a gatekeeper shall provide the
following services:
<itemize>
<item>Address Translation
<item>Admissions Control
<item>Bandwidth Control
<item>Zone Management
<item>Call Control Signaling
<item>Call Authorization
<item>Bandwidth Management
<item>Call Management
</itemize>

The GNU Gatekeeper implements most of these functions
based on the
<url url="http://www.openh323.org/" name="OpenH323">
protocol stack.

Recommendation H.323 is an international standard published by the
<url url="http://www.itu.int/" name="ITU">.
It is a communications standard for audio, video, and data over the Internet.
See also Paul Jones'
<url url="http://www.packetizer.com/iptel/h323/" name="primer on H.323">.

For a detailed description of what a gatekeeper does, see
<url url="http://www.webproforum.com/h323/topic06.html" name="here">.

<sect1>Copyright
<p>
It is covered by the
<htmlurl url="http://www.gnu.org/licenses/gpl.html" name="GNU General Public License"> (GNU GPL).
In addition to that, we explicitely grant
the right to link this code to the OpenH323 and OpenSSL library.

Generally speaking, the GNU GPL allows you to copy, distribute, resell or modify
the softwares, but it requires that all derived works must be published
under GNU GPL also.
That means that you must publish full source for all extensions to
the gatekeeper and for all programs you include the gatekeeper into.
See the file COPYING for details.

If that's not what you want, you must interface to the gatekeeper through
the status port and communicate via TCP with it.
That way you only have to integrate the basic funtionality into
the gatekeeper (and provide source for that) and can keep other parts
of your application private.

<sect1>Name
<p>
The formal name of this project is
<em>OpenH323 Gatekeeper - The GNU Gatekeeper</em>,
short <em/GnuGk/.
Please don't confuse it with other gatekeeper projects.

There are several open-source gatekeeper projects based on the OpenH323 protocol stack.
<itemize>
<item><url url="http://opengatekeeper.sourceforge.net/" name="OpenGatekeeper"> - by <url url="http://www.egoboo.com/" name="Egoboo">
<quote>A full featured gatekeeper freely available under MPL. The project has been inactive for a period of time now. There is an H.323 proxy based on OpenGatekeeper, see <url url="http://openh323proxy.sourceforge.net/" name="OpenH323Proxy">.</quote>
<item><url url="http://www.openh323.org/code.html" name="OpenGK"> - by <url url="http://www.equival.com.au/" name="Equivalence">
<quote>Only in a very primary grades.</quote>
<item>OpenH323 Gatekeeper - this one.
</itemize>

To have different gatekeepers with very similar names is really
confusing for most users.
Since our "OpenH323 Gatekeeper" was the first on the scene,
it is not our fault that others have chosen similar names.
But to make the destinction a little more clear without confusing
people even more, we have decided to give the project a
subtitle "OpenH323 Gatekeeper - The GNU Gatekeeper" and start
using <tt/gnugk/ as name for executables.

<sect1>Features
<p>
The version 2.2.1 contains the following new features and bugfixes:

<itemize>
<item>
Called-Station-Id number type can be selected between the original one
(dialed number) and the rewritten one. New <tt/UseDialedNumber/ config option
for <ref id="radauth" name="RadAuth">/<ref id="radaliasauth" name="RadAliasAuth">
/<ref id=radacct name="RadAcct"> modules, new %{Dialed-Number} variable
for <ref id=sqlacct name="SQLAcct"> and <ref id=fileacct name="FileAcct"> modules.

<item>
Ability to customize timestamp formats. New <tt/TimestampFormat/ config 
variables for main, <ref id="sqlacct" name="[SqlAcct]">, 
<ref id="radacct" name="[RadAcct]">, <ref id="fileacct" name="[FileAcct]">
and <ref id="calltable" name="[CallTable]"> sections.

<item>
RadAuth/RadAliasAuth modules can now add/remove endpoint aliases during
endpoint registration (using h323-ivr-in=terminal-alias: Cisco AV-Pair).

<item>
New <tt/TcpKeepAlive/ option to solve the problem with network errors
and calls hanging in the call table. See docs/keepalive.txt for more
details.

<item>
New status port <tt/RouteToGateway/ command.

</itemize>

<p>
The version 2.2.0 contains the following new features and bugfixes:

<itemize>
<item>
New <tt/RoundRobinGateways/ config option.

<item>
Call capacity limits and priority routing for gateways. New <tt/EP::/
config sections for per-endpoint configuration settings (see 
<ref id="epconfig" name="Per-Endpoint Configuration Settings">).

<item>
RTP proxy handling moved to a separate RTP proxy threads, so processing
of signaling messages does not block RTP packets. New <tt/RtpHandlerNumber/ 
config option.

<item>
REUSE_ADDRESS option enabled on listening sockets in non-LARGE_FDSET mode 
to fix a bug with the gatekeeper being unable to open listening ports after
restart.

<item>
Ability to set call destination in auth modules. RADIUS based call routing.

<item>
Support for SqlBill tariff table import from an OpenOffice.org Calc spreadsheet.

<item>
Fixed sourceInfo LRQ field handling - now it contains an H.323 identifier 
of the gatekeeper. Nonstandard data and gatekeeperIdentifier fields are set
only when the neighbor is defined as GnuGk.

<item>
Ability to set shared secrets for each radius server separatelly.

<item>
New, much faster, Radius client implementation.

<item>
Called-Party-Number-IE rewrite occured too late, causing auth/acct modules 
to receive the original number instead of the rewritten one.

<item>
Fixed proxying of RTP packets, so RTP sockets are not closed on temporary 
errors (like remote socket not yet ready). This bug affected especially 
NAT traversal and situation, when audio was sent very early, when reverse 
proxy path has not been yet established.

<item>
Fixed handling of RRJ from an alternate GnuGk.

<item>
New direct SQL accounting module (<ref id="sqlacct" name="[SQLAcct]">).

<item>
Handling multiple reply messages (RIP/LCF/LRJ) from neighbors fixed.

<item>
Support for CallCreditServiceControl in RCF and ACF messages, which allows
reporting call duration limit and user's account balance to endpoints. 
Currently RadAuth and RadAliasAuth modules support this feature.

<item>
Log file rotation, new <tt/LogFile/ config section, new <tt/setlog/ 
and <tt/rotatelog/ status interface commands.

<item>
Do not include an invalid access token (with null object identifier) 
in LCF to prevent interoperability problems.

<item>
Better handling of multiple calls over a single signalling channel 
by setting multipleCalls and maintainConnection H.225.0 fields to FALSE 
in all messages passing through the gatekeeper.

<item>
Better User-Name, Calling-Station-Id and Called-Station-Id handling.

<item>
IncludeEndpointIP flag for RadAuth, RadAliasAuth and RadAcct is obsolete,
these modules will always send Framed-IP-Address.

<item>
New Gatekeeper::Auth flag SetupUnreg to toggle Q.931 Setup authentication
for unregistered endpoints only.

<item>
New RADIUS h323-ivr-out=h323-call-id parameter that contains 
an H.323 Call Identifier.

<item>
The SQL billing from the contrib section can now authenticate users only 
by their IP (ignoring User-Name) and has a new, more flexible tariff/rating 
engine.

<item>
RadAliasAuth can authenticate now Setup messages without sourceAddress
field present (it will use Calling-Party-Number instead).

<item>
Better signal handling to prevent accidental gatekeeper crashes 
(due to SIGPIPE, for example).

<item>
CDR rotation per number of lines works correctly.

</itemize>

<p>
The version 2.2beta4 contains the following new features and bugfixes:

<itemize>
<item>
Parametrized FileAcct CDR output.

<item>
Do not list H.235 Auth Procedure I support in GCF messages, as it is not
fully implemented.

<item>
Fixed interoperability problem with some Cisco IOSes, because of copying
nonStandardData field from RAS requests to RAS replies.

<item>
Multiple calls over a single signalling channel are now gracefully handled 
using ReleaseComplete with the newConnectionNeeded indication

<item>
Permanent endpoints are correctly reloaded now, with removal
of permanent endpoints for which config entries have been deleted

<item>
Support for <tt/ExternalPasswordAuth/ module finally removed (although
the source code is only commented out for those who need this module).

<item>
SQL engine rewritten completelly to use a concept of SQL driver.
New modules SQLPasswordAuth and SQLAliasAuth added. MySQL and PostgreSQL
drivers implemented. Backward compatibility (MySQLAliasAuth and MySQLPasswordAuth) 
is maintained.

<item>
Per gateway E.164 rewriting of dialedDigits in addition 
to the global E.164 rewriting. Thanks to Ian Campbell!

<item>
A sample SQL/RADIUS billing example has been added to the contrib directory

<item>
A new config parameter ScreenSourceAddress introduced 
to screen calling party aliases present in the UUIE Setup element

<item>
Q.931 Setup authentication added to RadAuth module to allow
authentication based on crypto tokens carried inside Setup messages

<item>
Log rotation added

<item>
Applied the concept of output trace levels for the status interface. 
It allows to select amount of information a status client receives
(level 0 - silent mode + reloads; level 1 - CDRs, RouteRequests, reloads;
level 2 - everything: the default mode)

<item>
The GNU Gatekeeper Service for Windows contributed by Franz J Ehrengruber

<item>
Makefile to force users running configure script before the compilation

<item>
Better LOG_OFF Windows event handling to prevent gatekeeper shutdown
when the user logs out

<item>
Fixed SimplePasswordAuth module to read settings from 
<tt/SimplePasswordAuth/ section instead of <tt/Password/ section. 
Fixed MySQLPasswordAuth module to accept CacheTimeout parameter.
Default CacheTimeout for MySQLPasswordAuth and MySQLAliasAuth set to 0
(do not cache passwords/aliases at all).

<item>
RTP proxy fixed to (usually) not require RTCP channel and work better 
with T.38 faxes

<item>
Treat MCUs as gateways and allow MCUs to register prefixes

<item>
Fixed referencing to a temporary PString object after it is destroyed
when logging routing policy information

<item>
Flexible FileAcct CDR file rotation.

</itemize>

<p>
The version 2.2beta3 contains the following new features and bugfixes:
<itemize>
<item>
The config variable VirtualQueue has been renamed to VirtualQueueAliases 
(backward compatibility is maintained)

<item>
New VirtualQueuePrefixes and VirtualQueueRegex config variables introduced

<item>
Handling of multiple accounting modules has changed (new "alternative" control type added)

<item>
PostgreSQL authenticator modules have been added to the contrib directory

<item>
Q.931/H.225 Setup authentication (RadAliasAuth module implementation) added

<item>
<bf/addpasswd/ utility changed to require section name 
where the encrypted username/password will be stored

<item>
Fixed NULL reference in CallRec::SetSocket - caused crash in ForwardCall. Thanks to kubuqui cn!

<item>
Fixed invalid signed/unsigned conversions in RADIUS modules that caused
some functions to return unexpected results under certain circumstances

</itemize>

<p>
The version 2.2beta2 contains the following new features and bugfixes:
<itemize>
<item>
configure script to detect and control system settings and the compilation

<item>
RADIUS auth/acct modules ported from 2.0 and optimized

<item>
Plain text CDR accounting logger module (FileAcct) from Tamas Jalsovszky

<item>
Added "run as user" feature

<item>
New CTI virtual queues implementation from Chih-Wei Huang

<item>
Status line improvements (command expansion, repeat last command,
backspace handling for windows) from Hu Yuxin

</itemize>

<p>
The version 2.2beta1 contains the following new features:
<itemize>
<item>
A new method to detect NATed endpoints

<item>
Configurable, flexible routing policies

<item>
New neighboring system

<item>
Multithreaded RAS server

<item>
Support for multiple MySQL servers, MySQL can now be compiled on Windows
</itemize>

<p>
The version 2.0.6 has became a base for the new 2.2 gatekeeper version.

<p>
The version 2.0.6 is a bugfix release, plus the following enchancements:
<itemize>
<item>
RadAuth/RadAliasAuth modules can now add/remove endpoint aliases
during endpoint registration (see radauth.txt for more info).

<item>
added utilities to the contrib dir that allow the gnugk ro run
as a Windows service process. Thanks to Franz J Ehrengruber!

<item>
Windows improvements (project icon, version info, better console
handler). Thanks to Franz J Ehrengruber!

<item>
Radius Q.931 Setup authentication routines optimized.

<item>
gateway and neighbor prefixes match can also occur with alias types
(in addition to dialedDigits) partyNumber and h323_ID (containing only 0-9#*)

<item>
Added new VirtualQueuePrefixes and VirtualQueueRegex config variables.
These make possible to call virtual queue
not only with the exact alias name, but also with an alias that matches
configured prefixes or configured regular expression. Thanks to Max Speransky

<item>
accounting updates for calls in progress. Currenly only RadAcct
module implements this type of accounting event

<item>
improved Radius h323-xxx attributes handling (now understands
attributes both with embedded name strings and without them)
</itemize>

<p>
The version 2.0.6 is a bugfix release, plus the following enchancements:
<itemize>
<item>
FileAcct - plain CDR text accounting logger module.

<item>
Commandline option (-u) to change the gatekeeper process owner.

<item>
Improved virtual queues.

<item>
Full pre-paid support - both for registered endpoints (ARQ)
and for unregistered endpoints (Q.931 Setup). Call duration limit
is fully supported by RADIUS authenticators at the moment.
</itemize>

The version 2.0.5 is a bugfix release, plus the following enchancements:
<itemize>
<item>
a first TransferCall implementation

<item>
RADIUS H.235 (username/password) and alias authentication.

<item>
Modular accounting framework.

<item>
RADIUS accounting module.

<item>
Signalling channel authentication/authorization (Q.931/H.225.0 Setup).
Call duration limit (pre-paid services) can be controlled using this
authorization scheme. RADIUS Q.931 authentication/authorization
module is provided.

</itemize>

The version 2.0.3 is a bugfix release, plus a little enhancement:
<itemize>
<item>
Forward a call Setup to the specified endpoint directly on receiving
Q.931 Facility with reason <bf/callForwarded/.

<item>
Allow specify NATed endpoints manually.

<item>
Added a simple form of inbound call distribution. Calls to
a VirtualQueue can be routed to agents by an external distribution
application.
</itemize>

The new features added to version 2.0.2 are:
<itemize>
<item>
Add Citron's NAT Technology that allows transparently penetrate NAT boxes.Support multiple endpoints and calls concurrently.

<item>
The gatekeeper can sit behind an NAT box and registered by endpoints with
public IPs.

<item>
New extended fd_set structure, which allow the gatekeeper to support
thousands of concurrent calls in routed mode.

<item>
Support QoS by adding TOS flag to RTP/RTCP packets.

<item>
Login status port by username and password.
</itemize>

Of course, the major functions in version 2.0 are also included:
<itemize>
<item>
The registration table and call record table are redesigned, thread-safe,
and very efficient. Support ten thousands of registrations and thousands of
concurrent calls.

<item>
A new routed mode architecture that support H.225.0/Q.931 routed and
H.245 routed without forking additional threads. Thus the thread number
limit will not restrict the number of concurrent calls.

<item>
Support H.323 proxy by routing all logical channels, including RTP/RTCP
media channels and T.120 data channels. Logical channels opened by H.245
tunnelling and fast-connect procedure are also supported. In proxy mode,
there is no traffic between the calling and called parties directly. Thus
it is very useful if you have some endpoints using private IP behind an
NAT box and some endpoints using public IP outside the box.

<item>
Support gatekeepers cluster by exchanging LRQ/LCF/LRJ (neighboring function).
If the destination of a received LRQ is unknown, the GnuGk can forward it
to next hop. Therefore the GnuGk can work as a directory gatekeeper.

<item>
Support various authentication methods for selectable RAS requests, including
H.235 password (MD5, SHA-1 and CAT), IP pattern and prefixes matching. MySQL and
LDAP are supported as backend database for authentication.

<item>
Support alternate gatekeepers for redundancy and load balancing. If the
GnuGk is overloaded, the endpoints can be redirected to other gatekeepers.

<item>
Can work as an endpoint (gateway or terminal) by resigtering with a parent
gatekeeper. With this feature, building gatekeeper hierarchies is easily.

<item>
Monitor and control the GnuGk via TCP status port, including registration
and call statistics.

<item>
Output CDR(call detail record) to status port for backend billing system.
The CDR contains call identifier, calling and called IP, start and end time
and call duration.

<item>
Most configurations are changeable at runtime. The GnuGk rereads the
configurations on receiving <tt/reload/ command via status port, or on
receiving <tt/HUP/ signal (Unix platform).
</itemize>

<sect1>Download
<label id="download">
<p>
The newest stable and a development version are available at
<url url="http://www.gnugk.org/h323download.html" name="the download page">.

The very latest source code is in the CVS at
<url url="http://sourceforge.net/cvs/?group_id=4797" name="Sourceforge">
(<url url="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/openh323gk/" name="Web-GUI">).
Beware - that's the bleeding edge.

You can also download some executables from
<url url="http://www.gnugk.org/h323download.html" name="the download page">.
Only some versions are made available as executables.

<sect1>Mailing Lists
<p>
There are two mailing list for the project, one for the developers and one for the users.

General user questions should be send to the
<url url="mailto:Openh323gk-users@sourceforge.net" name="users mailing list">. You can find the list archive
<url url="http://sourceforge.net/mailarchive/forum.php?forum_id=8549" name="here">.
To join this mailing list, click
<url url="http://lists.sourceforge.net/lists/listinfo/openh323gk-users" name="here">.

To report problems or submit bugs/patches, send mails to the
<url url="mailto:Openh323gk-developer@sourceforge.net" name="developers mailing list">.
The list archive is
<url url="http://sourceforge.net/mailarchive/forum.php?forum_id=3079" name="here">. Please send user questions to the users mailinglist and keep this list to development! If you want to contribute to the project, please
<url url="http://lists.sourceforge.net/lists/listinfo/openh323gk-developer" name="join the mailing list">.

<bf/Note/:
Please don't send your questions as private emails to individual developer.
We are usually busy. We would <bf/not/ like to be your private consultant,
unless you'd like to pay us.
Send your problems to the appropriate public mailing list so everybody
can help you.

Also please don't send the GnuGk specific problems to the OpenH323
mailing list, or vice versa.
They are different projects, though closely related.

Before you sending an email, make sure you have read the related documents
carefully. Describe your problems clearly and precisely. Show us the
error messages or logs if there is any.

<sect1>Contributors
<p>
The current project coordinator is
<url url="http://www.willamowius.de/" name="Jan Willamowius">
<tt><htmlurl url="mailto:jan@willamowius.de" name="&lt;jan@willamowius.de&gt;"></tt>

The main features and functions of version 2.0 are contributed by
<url url="http://www.cwhuang.idv.tw/" name="Chih-Wei Huang">
<tt><htmlurl url="mailto:cwhuang@linux.org.tw" name="&lt;cwhuang@linux.org.tw&gt;"></tt>
and
<url url="http://www.citron.com.tw/" name="Citron Network Inc.">,
including thread-safe registration and call tables,
new routed mode architecture, H.323 proxy,
H.235 authentication and MySQL backend.

Michal Zygmuntowicz <tt><htmlurl url="mailto:m.zygmuntowicz@onet.pl" name="&lt;m.zygmuntowicz@onet.pl&gt;"></tt> has done some great work on Radius support and other improvements.

<!-- A team at url url="http://www.mediaways.net/" name="mediaWays" -->
<!-- is working on LDAP database-subsystem, overlapped sending -->
<!-- and advanced routing mechanisms. -->

The initial version of the gatekeeper has been developed by
Xiang Ping Chen, Joe Metzger and Rajat Todi.


<!----------          Next Section          ---------->
<sect>Compiling and Installing
<p>
<sect1>Compiling the Gatekeeper
<p>
To build the gatekeeper you need at least PWLib 1.5.0 and OpenH323 1.12.0 or later.
The development version of the gatekeeper usually needs the
most recent OpenH323 version available.
These libraries are available at
<url url="http://www.openh323.org/code.html" name="OpenH323 Download Page">.
See the instructions on
<url url="http://www.openh323.org/build.html" name="how to compile the OpenH323 code">.

Order of compiling:
<enum>
<item>PWLib (release + debug version)
<item>OpenH323
<item>OpenH323 test application (not needed, just to make sure everything works so far)
<item>The Gatekeeper
</enum>

On Unix do a <tt/configure/ and <tt/make debug/ or <tt/make opt/
in the gatekeeper directory to build debug or release version, respectively.
Use <tt/make both/ to build both versions.
Note you have to use GCC 3.3.x or later. The older version may not work.
Good practice is to do a <tt/make debugdepend/ or <tt/make optdepend/
in the gatekeeper directory before starting actual compilation (make debug or
make opt) - these commands build approtiate dependency lists, so after
you will update your sources from CVS, all affected files will get recompiled.
Otherwise you can finish with the Gatekeeper partially compiled with the older
headers and partially with the updated headers - a very bad thing.
On Windows just open and compile the provided project (<tt/gk.dsw/) for
Microsoft Visual C++ 6.0 or 7.0 (Visual C++ 5.0 is too old).<newline>

Type <tt/configure --help/ to see a detailed list of all compile time
options. You can use them to enable or disable some features of the gatekeeper.
For example, if you do not need RADIUS just type: <tt/configure --disable-radius/.<newline>

To build the gatekeeper that is statically linked with system and OpenH323 libraries,
<tt/make optnoshared/ or <tt/make debugnoshared/ has to be used.

In order to use the gatekeeper under heavy load, enabling LARGE_FDSET feature
is recommended (configure --with-large-fdset=1024). Most systems also need 
kernel reconfiguration/recompilation in order to allow more than 1024 sockets
to be allocated for a single process. Note that the PWLib library starting
from version 1.5.3 supports a similar feature too, so you can choose between
LARGE_FDSET GnuGk and PWLib implementation. GnuGk native implementation gives
better performance results. Maximum LARGE_FDSET value should be calculated 
based upon predicted maximum sockets usage. A rule of thumb may be:
<tscreen><verb>
MAX_NUMBER_OF_CONCURRENT_CALLS * 10 * 120%

Where:
10 = 2 sockets for Q.931 + 2 sockets for H.245 + 6 sockets for RTP and other stuff
</verb></tscreen>
So for 100 concurrent calls you don't need more than ca. 1024 sockets in the
LARGE_FDSET.

<sect1>Installing the Gatekeeper
<p>
There is no special installation procedure needed.
Just copy the executable to the directory you like
and create a config file for it.
There are several config examples in the <tt>etc/</tt> subdirectory
of source tree. See section <ref id="config" name="Configuration File">
for detailed explanations.

For example, in Linux x86 platform, the optimized executable <tt/gnugk/
is produced in <tt>obj_linux_x86_r/</tt> subdirectory.
You may copy it to <tt>/usr/sbin/</tt>, create a config in
<tt>/etc/gnugk.ini</tt> and start it by
<tscreen><verb>
$ /usr/sbin/gnugk -c /etc/gnugk.ini -o /var/log/gnugk.log -ttt
</verb></tscreen>
See section <ref id="commandline" name="Command Line Options"> for details.

<sect1>Pre-Built Binaries
<p>
If you do not wish to compile the gatekeeper from source,
there are several pre-built `packages' available from
<url url="http://sourceforge.net/project/showfiles.php?group_id=4797" name="SourceForge">.
Not all versions will be made available as binaries - check what is avilable.

<bf/Tar packages (.tgz or .tar.gz)/<p>
Download the tar file and enter the following command as <tt/root/,
substitute in the name of the file you downloaded.
<tscreen><verb>
$ tar xvzf gnugk-x.x.x.tar
</verb></tscreen>

<bf/Debian packages (.deb)/<p>
Debian includes the gatekeeper as openh323gk package.
You can install it by using the following command as <tt/root/:
<tscreen><verb>
$ apt-get install openh323gk
</verb></tscreen>


<!----------          Tutorial Section          ---------->
<sect>Getting Started (Tutorial)
<p>
<sect1>A first simple experiment
<p>
To see that all components are up and running, get
2 Linux workstations, both connected to the LAN.
Make sure you have at least version 1.1 of OpenH323 and OhPhone installed.
On the first machine run the gatekeeper and ohphone (on
different consoles):

<tscreen><verb>
jan@machine1 > gnugk -ttt
</verb></tscreen>

Now the gatekeeper is running in direct mode.
The "<tt/-ttt/" option tells the gatekeeper to do a lot of debug output
on the console (you can direct that output to a file with "<tt/-o logfile/").

<tscreen><verb>
jan@machine1 > ohphone -l -a -u jan
</verb></tscreen>

Now this OhPhone is listening (<tt/-l/) for calls and will automatically
accept them (<tt/-a/). It has registered as user jan with the gatekeeper
that it will automatically detect. (If the auto detect fails for some
reason use "<tt/-g 1.2.3.4/" to specify the IP number the gatekeeper
is running on.)

On the second machine run ohphone only:

<tscreen><verb>
peter@machine2 > ohphone -u peter jan
</verb></tscreen>

The second instance of OhPhone registers with the auto detected
gatekeeper as user peter and tries to call user jan.
The gatekeeper will resolve the username to the IP number from
where user jan has registered (machine1 in this case) and OhPhone
will call the other instance of OhPhone on machine one.

The first instance of OhPhone will accept that call and Peter and Jan can chat.

<sect1>Using the Status interface to monitor the gatekeeper
<p>
Now we try to see which messages are handled by the gatekeeper.
On a new console on machine1 we use telnet to connect to the gatekeeper:

<tscreen><verb>
jan@machine1 > telnet machine1 7000
</verb></tscreen>

Most probably we'll get an "Access forbidden!" message, because
not everybody is allowed to spy.

Now we create a file called <tt/gatekeeper.ini/ and put it in the
directory where we start the gatekeeper.
<tt/gatekeeper.ini/ only contains 4 lines:

<tscreen><verb>
[Gatekeeper::Main]
Fourtytwo=42
[GkStatus::Auth]
rule=allow
</verb></tscreen>

Stop the gatekeeper with Ctrl-C and restart it.
When we do the telnet again, we stay connected with the gatekeeper.
Now repeat the first experiment where Peter calls Jan and see which
messages are handled by the gatekeeper in non-routed mode.
There is a number of commands that can be issued in this telnet session:
Type "help" to see them.
To end the telnet session with the gatekeeper type "quit" and hit Enter.

<sect1>Starting the gatekeeper in routed mode
<p>
Starting the gatekeeper in routed mode means that the gatekeeper
uses "gatekeeper routed signalling" for all calls. In this
mode the gatekeeper all signalling messages go through the gatekeeper
and it has much greater control over the calls.

<tscreen><verb>
jan@machine1 > gnugk -r
</verb></tscreen>

Now the gatekeeper is running in routed mode. Telnet to the status port
and make a call to see what messages are now handled by the gatekeeper.

Note that all media packets (audio and video) are still sent
directly between the endpoints (the 2 instances of ohphone).

Since gatekeeper routed signalling is much more complicated you are
much more likely to hit a bug n the gatekeeper in this mode.
But if it breaks, you get to keep the pieces. ;-)

<p>
<sect1>A virtual PBX: Disconnecting calls
<p>
Until now the gatekeeper has only acted as a mechanism
to resolve symbolic names to IP addresses. Thats an important
function but hardly exciting.

Since the gatekeeper has a lot of control over the calls,
it can terminate them for example. When we are
connected to the status port, we can list all active calls
with "<tt/PrintCurrentCalls/". To terminate a call, we can
say "<tt/Disconnectip 1.2.3.4/" for one of its endpoints.

One could for example write a simple script that connects to
the status port and listens for all ongoing calls and terminates
them after 5 minutes, so no user can over use system resources.

Take a look at the other telephony functions like TransferCall to see what else is available.

<sect1>Routing calls over a gateway to reach external users
<p>
Without using a gateway you can only call other people with an
IP phone over the Internet. To reach people with ordinary telephones
you must use a gateway.

<tscreen><verb>
_________________          ______________
| endpoint "jan"|          |            |
| 192.168.88.35 |--------->| Gatekeeper |
|_______________|          |            |
_________________          |            |
| gateway "gw1" | outgoing |            |
| 192.168.88.37 |<---------|____________|
|_______________|
</verb></tscreen>

The gatekeeper has to know which calls are supposed to be routed
over the gateway and what numbers shall be called directly.
Use the [RasSrv::GWPrefixes] section of the config file to tell
the gatekeeper the prefix of numbers that shall be routed over the
gateway.

<tscreen><verb>
[RasSrv::GWPrefixes]
gw1=0
</verb></tscreen>

This entry tells the gatekeeper to route all calls to E.164 numbers
starting with 0 to the gateway that has registered with the H.323
alias "gw1". If there is no registered gateway with that alias the
call will fail. (Note that you must use the gateway alias - you
can't just tell the gatekeeper the IP number of the gateway.)


<sect1>Rewriting E.164 numbers
<p>
When using a gateway you often have to use different numbers internally
and rewrite them before sending them over a gateway into the telephone
network. You can use the <ref id="rewrite" name="RasSrv::RewriteE164">
section to configure that.

Example:
You want to call number 12345 with you IP Phone and would like to
reach number 08765 behind a gateway called "gw1".

<tscreen><verb>
[RasSrv::GWPrefixes]
gw1=0

[RasSrv::RewriteE164]
12345=08765
</verb></tscreen>

You can also configure rewriting of E.164 numbers based on which gateway
you are receiving a call from or sending a call to using the
<ref id="gwrewrite" name="RasSrv::GWRewriteE164"> section.

Example:
You have two different gateways ("gw1" and "gw2") which you are sending
calls with prefix 0044 to, but which require a different prefix to be
added to the number after the routing has selected the gateway. This
might be for identification purposes for example.

<tscreen><verb>
[RasSrv::GWPrefixes]
gw1=0044
gw2=0044

[RasSrv::GWRewriteE164]
gw1=out=0044=77770044
gw2=out=0044=88880044
</verb></tscreen>

Example:
You want to identify calls from a particular gateway "gw1" with a specific
prefix before passing these calls to another gateway "gw2".

<tscreen><verb>
[RasSrv::GWPrefixes]
gw2=1

[RasSrv::GWRewriteE164]
gw1=in=00=123400
</verb></tscreen>

<!----------          Reference Section          ---------->
<sect>Using the Gatekeeper (Reference)
<p>
The behavior of the gatekeeper is completely determined by the command line
options and configuration file. Some command line options may override
the setting of the configuration file.
For example, the option <tt/-l/ overrides the setting <tt/TimeToLive/
in the configuration file.

<sect1>Command Line Options
<label id="commandline">
<p>
Almost every option has a short and a long format, e.g.,
<tt/-c/ is the same as <tt/--config/.
<p>
<sect2>Basic
<p>
<descrip>
<tag/<tt/-h  --help//
Show all available options and quit the program.
<tag/<tt/-c  --config filename//
Specify the configuration file to use.
<tag/<tt/-s  --section section//
Specify which main section to use in the configuration file. The default is [Gatekeeper::Main].
<tag/<tt/-i  --interface IP//
Specify the interface (IP number) that the gatekeeper listens to.
You should leave out this option to let the gatekeeper automatically determine
the IP it listens to, unless you want the gatekeeper only binds to
a specified IP.
<tag/<tt/-l  --timetolive n//
Specify the time-to-live timer (in seconds) for endpoint registration.
It overrides the setting <tt/TimeToLive/ in the configuration file.
See <ref id="ttl" name="there"> for detailed explanations.
<tag/<tt/-b  --bandwidth n//
Specify the total bandwidth available for the gatekeeper.
Without specifying this option, the bandwidth management
is disable by default.
<tag/<tt/--pid filename//
Specify the pid file, only valid for Unix version.
<tag/<tt/-u  --user name//
Run the gatekeeper process as this user. Only valid for Unix versions.
</descrip>

<sect2>Gatekeeper Mode
<p>
The options in this subsection override the settings in the
<ref id="routed" name="[RoutedMode] section"> of the configuration file.
<descrip>
<tag/<tt/-d  --direct//
Use direct endpoint call signalling.
<tag/<tt/-r  --routed//
Use gatekeeper routed call signalling.
<tag/<tt/-rr  --h245routed//
Use gatekeeper routed call signalling and H.245 control channel.
</descrip>

<sect2>Debug Information
<p>
<descrip>
<tag/<tt/-o  --output filename//
Write trace log to the specified file.
<tag/<tt/-t  --trace//
Set trace verbosity. The more <tt/-t/ you add, the more verbose to output.
For example, use <tt/-ttttt/ to set the trace level to 5.
</descrip>

<sect1>Configuration File
<label id="config">
<p>
The configuration file is a standard text file. The basic format is:

<tscreen><verb>
[Section String]
Key Name=Value String
</verb></tscreen>

Comments are marked with a hash (<tt/#/) or a semicolon (<tt/;/)
at the beginning of a line.

The file
<tt/complete.ini/
contains all available sections for the GnuGk.
In most cases it doesn't make sense to use them all at once.
The file is just meant as a collection of examples for many settings.

The configuration file can be changed at runtime.
Once you modify the configuration file, you may issue <tt/reload/ command
via status port, or send a signal <tt/HUP/ to the gatekeeper process on Unix.
For example,
<tscreen><verb>
kill -HUP `cat /var/run/gnugk.pid`
</verb></tscreen>

<bf/Note/
Some section names in GnuGk 2.0.0 are named &lsqb;RasSrv::*&rsqb;,
while others are named &lsqb;RasSvr::*&rsqb;. This inconsistency confused users.
In 2.0.1 all sections are corrected to &lsqb;RasSrv::*&rsqb;.
If you upgrade from 2.0.0 or earlier version, remember to change the
section names, or GnuGk will refuse to start.

<sect2>Section &lsqb;Gatekeeper::Main&rsqb;
<p>
<itemize>
<item><tt/Fourtytwo=42/<newline>
Default: <tt>N/A</tt>
<p>
This setting is used to test the presence of the config file. If it
is not found, a warning is issued.
Make sure it's in all your config files.

<item><tt/Name=OpenH323GK/<newline>
Default: <tt/OpenH323GK/
<p>
Gatekeeper identifier of this gatekeeper. The gatekeeper will only respond to
GRQs for this ID and will use it in a number of messages to its endpoints.

<item><tt/Home=192.168.1.1/<newline>
Default: <tt/0.0.0.0/
<p>
The gatekeeper will listen for requests on this IP number.
By default, the gatekeeper listens on all interfaces of your host.
You should leave out this option,
unless you want the gatekeeper only to bind to a specified IP.

<item><tt>NetworkInterfaces=192.168.1.1/24,10.0.0.1/0</tt><newline>
Default: <tt>N/A</tt>
<p>
Specify the network interfaces of the gatekeeper. By default the gatekeeper
will detect the interfaces of your host automatically. There are two situations
that you may want to use this option. One is automatical detection failed,
another is the gatekeeper is behind an NAT box and allow endpoints with
public IPs to register with. In this case you should set the option just as
the gatekeeper is running on the NAT box.

<item><tt/EndpointIDSuffix=_gk1/<newline>
Default: <tt/_endp/
<p>
The gatekeeper will assign a unique identifier to each registered endpoint.
This option can be used to specify a suffix to append to the endpoint identifier. This is only usefull when using more than one gatekeeper.

<item><label id="ttl"><tt/TimeToLive=300/<newline>
Default: <tt/-1/
<p>
An endpoint's registration with a gatekeeper may have a limited life span.
The gatekeeper specifies the registration duration of an endpoint
by including a <bf/timeToLive/ field in the RCF message.
After the specified time, the registration has expired.
The endpoint shall periodically send an RRQ having the <bf/keepAlive/
bit set prior to the expiration time. Such a message may include a
minimum amount of information as described in H.225.0.
This is called a lightweight RRQ.

This configuration setting specifies the time-to-live timer in seconds until the registration expires.
Note the endpoint may request a shorter <bf/timeToLive/ in the RRQ message
to the gatekeeper.
To avoid an overload of RRQ messages,
the gatekeeper automatically adjusts this timer
to 60 seconds if you give a lesser value!

After the expiration time,
the gatekeeper will subsequently send two IRQ messages to query
if the endpoint is still alive. If the endpoint responds with an IRR,
the registration will be extended. Otherwise the gatekeeper will send
a URQ with reason <bf/ttlExpired/ to the endpoint.
The endpoint must then re-register with the gatekeeper using a full RRQ message.

To disable this feature, set it to <tt/-1/.

<item><tt/TotalBandwidth=100000/<newline>
Default: <tt/-1/
<p>
Total bandwidth available to be given to endpoints.
By default this feature is off. Be carefull when using it,
because many endpoints have buggy implementations.

<item><tt/RedirectGK=Endpoints > 100 || Calls > 50/<newline>
Default: <tt>N/A</tt>
<p>
This option allow you to redirect endpoints to alternate gatekeepers
when the gatekeeper overloaded.
For example, with the above setting the gatekeeper will
reject an RRQ if registered endpoints exceed 100,
or reject an ARQ if concurrent calls exceed 50.

Furthermore, you may explicitly redirect all endpoints by
setting this option to <tt/temporary/ or <tt/permanent/.
The gatekeeper will return an RAS rejection message with a list of
alternate gatekeepers defined in <tt/AlternateGKs/.
Note that a <tt/permanent/ redirection means that the redirected endpoints
will not register with this gatekeeper again.
Please also note the function only takes effect to H.323 version 4
compliant endpoints.

<item><tt/AlternateGKs=1.2.3.4:1719:false:120:OpenH323GK/<newline>
Default: <tt>N/A</tt>
<p>
We allow for existence of another gatekeeper to provide redundancy.
This is implemented in a active-active manner. Actually, you might get
into a (valid !) situation where some endpoints are registered with the
first and some are registered with the second gatekeeper.
You should even be able use the two gatekeepers in a round_robin fashion
for load-sharing (that's untested, though :-)).
If you read on, "primary GK" refers to the gatekeeper you're currently
configuring and "alternate GK" means the other one.
The primary GK includes a field in the RCF to tell endpoints which alternate
IP and gatekeeper identifier to use.
But the alternate GK needs to know about every
registration with the primary GK or else it would reject calls.
Therefore our gatekeeper can forward every RRQ to an alternate IP address.

The AlternateGKs config option specifies the fields contained in
the primary GK's RCF. The first and second fields of this string define
where (IP, port) to forward to.
The third tells endpoints whether they need to register with the alternate GK
before placing calls. They usually don't because we forward their RRQs, so they
get registered with the alternate GK, too.
The fourth field specified the priority for this GK.
Lower is better, usually the primary GK is considered to have priority 1.
The last field specifies the alternate gatekeeper's identifier.

<item><tt/SendTo=1.2.3.4:1719/<newline>
Default: <tt>N/A</tt>
<p>
Although this information is contained in AlternateGKs, you must still
specify which address to forward RRQs to. This might differ from AlternateGK's
address, so it's a separate config option (think of multihomed machines).

<item><tt/SkipForwards=1.2.3.4:5.6.7.8/<newline>
Default: <tt>N/A</tt>
<p>
To avoid circular forwarding, you shouldn't forward RRQs you get from the
other GK (this statement is true for both, primary and alternate GK).
Two mechanisms are used to identify whether a request should be forwarded.
The first one looks for a flag in RRQ. Since few endpoints implement this,
we need a second, more reliable way.
Specify the other gatekeeper's IP in this list.

<item><tt/StatusPort=7000/<newline>
Default: <tt/7000/
<p>
Status port to monitor the gatekeeper.
See <ref id="monitor" name="this section"> for details.

<item><tt/StatusTraceLevel=2/<newline>
Default: <tt/2/
<p>
Default output trace level for new status interface clients.
See <ref id="monitor" name="this section"> for details.

<item><tt/TimestampFormat=ISO8601/<newline>
Default: <tt/Cisco/
<p>
Control default format of timestamp strings generated by the gatekeeper.
This option affects <ref id="sqlacct" name="[SqlAcct]">, 
<ref id="radacct" name="[RadAcct]">, <ref id="fileacct" name="[FileAcct]">
and other modules, except <ref id="calltable" name="[CallTable]">.
You can further customize timestamp formatting per-module by configuring
per-module <tt/TimestampFormat/ setting.
<p>
There are four predefined formats:
<itemize>
<item><tt/RFC822/ - a default format used by the gatekeeper (example: Wed, 10 Nov 2004 16:02:01 +0100)
<item><tt/ISO8601/ - standard ISO format (example: 2004-11-10 T 16:02:01 +0100)
<item><tt/Cisco/ - format used by Cisco equipment (example: 16:02:01.534 CET Wed Nov 10 2004)
<item><tt/MySQL/ - simple format that MySQL can understand (example: 2004-11-10 16:02:01)
</itemize>
<p>
If you need another format, you can build your own format string, using
rules known from <tt/strftime/ C function (see man strftime or search MSDN for strftime).
In general, the format string consists of regular character and format codes, preceeded
by a percent sign. Example: "%Y-%m-%d and percent %%" will result in "2004-11-10 and percent %".
Some common format codes:
<itemize>
<item><tt/%a/ - abbreviated weekday name
<item><tt/%A/ - full weekday name
<item><tt/%b/ - abbreviated month name
<item><tt/%B/ - full month name
<item><tt/%d/ - day of month as decimal number
<item><tt/%H/ - hour in 24-hour format
<item><tt/%I/ - hour in 12-hour format
<item><tt/%m/ - month as decimal number
<item><tt/%M/ - minute as decimal number
<item><tt/%S/ - second as decimal number
<item><tt/%y/ - year without century
<item><tt/%Y/ - year with century
<item><tt/%u/ - microseconds as decimal number (<bf/this is a GnuGk extension/)
<item><tt/%z/ - time zone abbreviation (+0100)
<item><tt/%Z/ - time zone name
<item><tt/%%/ - percent sign
</itemize>

</itemize>

Most users will never need to change any of the following values.
They are mainly used for testing or very sophisticated applications.

<itemize>
<item><tt/UseBroadcastListener=0/<newline>
Default: <tt/1/
<p>
Defines whether to listen to broadcast RAS requests. This requires
binding to all interfaces on a machine so if you want to run multiple
instances of gatekeepers on the same machine you should turn this off.

<item><tt/UnicastRasPort=1719/<newline>
Default: <tt/1719/
<p>
The RAS channel TSAP identifier for unicast.

<item><tt/MulticastPort=1718/<newline>
Default: <tt/1718/
<p>
The RAS channel TSAP identifier for multicast.

<item><tt/MulticastGroup=224.0.1.41/<newline>
Default: <tt/224.0.1.41/
<p>
The multicast group for the RAS channel.

<item><tt/EndpointSignalPort=1720/<newline>
Default: <tt/1720/
<p>
Default port for call signalling channel of endpoints.

<item><tt/ListenQueueLength=1024/<newline>
Default: <tt/1024/
<p>
Queue length for incoming TCP connection.

<item><tt/SignalReadTimeout=1000/<newline>
Default: <tt/1000/
<p>
Time in miliseconds for read timeout on call signalling channels (Q931).

<item><tt/StatusReadTimeout=3000/<newline>
Default: <tt/3000/
<p>
Time in miliseconds for read timeout on status channel.

<item><tt/StatusWriteTimeout=5000/<newline>
Default: <tt/5000/
<p>
Time in miliseconds for write timeout on status channel.
</itemize>

<sect2>Section &lsqb;LogFile&rsqb;
<label id="logfile">
<p>
This section defines log file related parameters. Currently it allows
users to specify log file rotation options.

<itemize>
<item><tt/Rotate=Hourly | Daily | Weekly | Monthly/<newline>
Default: <tt>N/A</tt>
<p>
If set, the log file will be rotated based on this setting. Hourly rotation
enables rotation once per hour, daily - once per day, weekly - once per week
and monthly - once per month. An exact rotation moment is determined by a combination
of <tt/RotateDay/ and <tt/RotateTime/ variables. During rotation, an existing 
file is renamed to CURRENT_FILENAME.YYYYMMDD-HHMMSS, where YYYYMMDD-HHMMSS 
is replaced with the current timestamp, and new lines are logged to an empty 
file. To disable the rotation, do not set <tt/Rotate/ parameter or set it to 0.

<descrip>
<tag/Example 1 - rotate every hour (00:45, 01:45, ..., 23:45):/
<tt/&lsqb;LogFile&rsqb;/<newline>
<tt>Rotate=Hourly</tt><newline>
<tt>RotateTime=45</tt><newline>
</descrip>

<descrip>
<tag/Example 2 - rotate every day at 23:00 (11PM):/
<tt/&lsqb;LogFile&rsqb;/<newline>
<tt>Rotate=Daily</tt><newline>
<tt>RotateTime=23:00</tt><newline>
</descrip>

<descrip>
<tag/Example 3 - rotate every Sunday at 00:59:/
<tt/&lsqb;LogFile&rsqb;/<newline>
<tt>Rotate=Weekly</tt><newline>
<tt>RotateDay=Sun</tt><newline>
<tt>RotateTime=00:59</tt><newline>
</descrip>

<descrip>
<tag/Example 4 - rotate on the last day of each month:/
<tt/&lsqb;LogFile&rsqb;/<newline>
<tt>Rotate=Monthly</tt><newline>
<tt>RotateDay=31</tt><newline>
<tt>RotateTime=23:00</tt><newline>
</descrip>
</itemize>

<sect2>Section &lsqb;RoutedMode&rsqb;
<label id="routed">
<p>
Call signalling messages may be passwd in two ways.
The first method is Direct Endpoint Call Signalling, in which case
the call signalling messages are passed directly between the endpoints.
The second method is Gatekeeper Routed Call Signalling. In this method,
the call signalling messages are routed through the gatekeeper
between the endpoints. The choice of which methods is used is made by
the gatekeeper.

When Gatekeeper Routed call signalling is used, the gatekeeper may choose
whether to route the H.245 control channel and logical channels.

<descrip>
<tag/Case I./
The gatekeeper doesn't route them.
The H.245 control channel and logical channels are established directly
between the endpoints.
<tag/Case II./
The H.245 control channel is routed between
the endpoints through the gatekeeper, while the logical channels
are established directly between the endpoints.
<tag/Case III./
The gatekeeper routes the H.245 control channel,
as well as all logical channels, including RTP/RTCP for audio and video,
and T.120 channel for data. In this case, no traffic is passed
directly between the endpoints. This is usually called an H.323 Proxy,
which can be regarded as an H.323-H.323 gateway.
</descrip>

This section defines the gatekeeper routed mode options (case I &amp; II).
The proxy feature is defined in the <ref id="proxy" name="next section">.
All settings in this section are affected by reloading.

<itemize>
<item><tt/GKRouted=1/<newline>
Default: <tt/0/
<p>
Whether to enable the gatekeeper routed mode.

<item><tt/H245Routed=1/<newline>
Default: <tt/0/
<p>
Whether to route the H.245 control channel. Only takes effect if <tt/GKRouted=1/.

<item><tt/CallSignalPort=0/<newline>
Default: <tt/1721/
<p>
The port of call signalling for the gatekeeper.
The default port is <tt/1721/. We don't use the well-known port <tt/1720/
so you can run an H.323 endpoint in the same machine of the gatekeeper.
You may set it to <tt/0/ to let the gatekeeper choose an arbitrary port.

<item><tt/CallSignalHandlerNumber=2/<newline>
Default: <tt/1/
<p>
The number of call signalling handler. You may increase this number
in a heavy loaded gatekeeper. The number can only be increased
at runtime. If you have a SMP machine, you can set this number
to your number of CPUs.

<item><tt/RtpHandlerNumber=2/<newline>
Default: <tt/1/
<p>
The number of RTP proxy handling threads.

<item><tt/AcceptNeighborsCalls=1/<newline>
Default: <tt/1/
<p>
With this feature enabled, the call signalling thread will accept calls
without a pre-existing CallRec found in the CallTable, provided an endpoint
corresponding to the destinationAddress in Setup can be found in the
RegistrationTable, and the calling party is its neighbors or parent GK.
The gatekeeper will also use it's own call signalling address in LCF
in responding to an LRQ. That means, the call signalling will be routed
to GK2 in GK-GK calls.
As a result, the CDRs in GK2 can correctly show the connected
time, instead of 'unconnected'.

<item><tt/AcceptUnregisteredCalls=1/<newline>
Default: <tt/0/
<p>
With this feature enabled, the gatekeeper will accept calls
from any unregistered endpoint.
However, it raises security risks. Be careful to use it.

<item><tt/RemoveH245AddressOnTunneling=1/<newline>
Default: <tt/0/
<p>
Some endpoints send h245Address in the UUIE of Q.931 even when h245Tunneling
is set to TRUE. This may cause interoperability problems. If the option
is TRUE, the gatekeeper will remove h245Address when h245Tunneling flag
is TRUE. This enforces the remote party to stay in tunnelling mode.

<item><tt/RemoveCallOnDRQ=0/<newline>
Default: <tt/1/
<p>
With this option turning off, the gatekeeper will not disconnect a call
if it receives a DRQ for it. This avoids potential race conditions when
a DRQ overtakes a Release Complete.
This is only meaningful in routed mode because in direct mode, the only
mechanism to signal end-of-call is a DRQ.

<item><tt/DropCallsByReleaseComplete=1/<newline>
Default: <tt/0/
<p>
According to Recommendation H.323, the gatekeeper could tear down a call
by sending RAS DisengageRequest to endpoints.
However, some bad endpoints just ignore this command.
With this option turning on, the gatekeeper will send Q.931
Release Complete instead of RAS DRQ to both endpoints to force them
drop the call.

<item><tt/SendReleaseCompleteOnDRQ=1/<newline>
Default: <tt/0/
<p>
On hangup, the endpoint sends both Release Complete within H.225/Q.931 and
DRQ within RAS. It may happen that DRQ is processed first, causing the
gatekeeper to close the call signalling channel, thus preventing the
Release Complete from being forwarding to the other endpoint.
Though the gatekeeper closes the TCP channel to the destination,
some endpoints (e.g. Cisco CallManager) don't drop the call even if
the call signalling channel is closed.
This results in phones that keep ringing if the caller hangs up
before the callee pickups.
Setting this parameter to <tt/1/ makes the gatekeeper always send
Release Complete to both endpoints before closing the call when
it receives DRQ from one of the parties.

<item><tt/SupportNATedEndpoints=1/<newline>
Default: <tt/0/
<p>
Whether to allow an endpoint behind an NAT box register to the gatekeeper.
If yes, the gatekeeper will translate the IP address in Q.931 and H.245
channel into the IP of NAT box.

Since 2.0.2, the GnuGk supports NAT outbound calls (from an endpoint behind NAT
to public networks) directly without any necessary modification
of endpoints or NAT box. Just register the endpoint with the GnuGk
and you can make call now.

<item><tt/ScreenDisplayIE=MyID/<newline>
Default: <tt>N/A</tt>
<p>
Modify the DisplayIE of Q.931 to the specified value.

<item><tt/ScreenCallingPartyNumberIE=0965123456/<newline>
Default: <tt>N/A</tt>
<p>
Modify the CallingPartyNumberIE of Q.931 to the specified value.

<item><tt/ScreenSourceAddress=MyID/<newline>
Default: <tt>N/A</tt>
<p>
Modify the sourceAddress field of UUIE element from Q.931 Setup message.

<item><tt/ForwardOnFacility=1/<newline>
Default: <tt>1</tt>
<p>
If yes, on receiving Q.931 Facility with reason <bf/callForwarded/,
the gatekeeper will forwards call Setup directly to the forwarded endpoint,
instead of passing the message back to the caller.
If you have broken endpoints that can't handle Q.931 Facility with reason
<bf/callForwarded/, turn on this option.

<item><tt/ShowForwarderNumber=0/<newline>
Default: <tt/0/
<p>
Whether to rewrite the calling party number to the number of forwarder.
It's usually used for billing purpose.
Only valid if <tt/ForwardOnFacility=1/.

<item><tt/Q931PortRange=20000-20999/<newline>
Default: <tt/0/ (random)
<p>
Specify the range of TCP port number for Q.931 signalling channels.
Note the range size may limit the number of concurrent calls.

<item><tt/H245PortRange=30000-30999/<newline>
Default: <tt/0/ (random)
<p>
Specify the range of TCP port number for H.245 control channels.
Note the range size may limit the number of concurrent calls.

<item><tt/ConnectTimeout=60000/<newline>
Default: <tt>180000</tt>
<p>
Timeout value in milliseconds to wait before removing
unconnected calls from the call table. This is a guard timer
that does not allow unconnected calls to hang forever
in the call table.
Note that making this value too short may result
in calls dropped before answered.

<item><tt/TcpKeepAlive=0/<newline>
Default: <tt/1/
<p>
Enable/disable keepalive feature on TCP signaling sockets. This can
help to detect inactive signaling channels and prevent dead calls from hanging
in the call table. For this option to work, you also need to tweak system
settings to adjust keep alive timeout. See docs/keepalive.txt for more details.

</itemize>

<p>
<sect2>Section &lsqb;Proxy&rsqb;
<label id="proxy">
<p>
The section defines the H.323 proxy features. It means the gatekeeper will
route all the traffic between the calling and called endpoints, so there
is no traffic between the two endpoints directly. Thus it is very useful
if you have some endpoints using private IP behind an NAT box and some
endpoints using public IP outside the box.

The gatekeeper can do proxy for logical channels of RTP/RTCP (audio and video)
and T.120 (data). Logical channels opened by fast-connect procedures
or H.245 tunnelling are also supported.

Note to make proxy work, the gatekeeper must have <bf/direct connection/
to both networks of the caller and callee.

<itemize>
<item><tt/Enable=1/<newline>
Default: <tt/0/
<p>
Whether to enable the proxy function. You have to enable gatekeeper
routed mode first (see the <ref id="routed" name="previous section">).
You don't have to specify H.245 routed.
It will automatically be used if required.

<item><tt>InternalNetwork=10.0.1.0/24</tt><newline>
Default: <tt>N/A</tt>
<p>
Define the networks behind the proxy. Multiple internal networks are allow.
The proxy route channels only of the communications between one endpoint
in the internal network and one external. If you don't specify it, all calls
will be proxied.

<descrip>
<tag/Format:/
<tt>InternalNetwork=network address/netmask[,network address/netmask,...]</tt>
<p>
The netmask can be expressed in decimal dot notation or
CIDR notation (prefix length), as shown in the example.
<tag/Example:/
<tt>InternalNetwork=10.0.0.0/255.0.0.0,192.168.0.0/24</tt>
</descrip>

<item><tt/T120PortRange=40000-40999/<newline>
Default: <tt/0/ (random)
<p>
Specify the range of TCP port number for T.120 data channels.
Note the range size may limit the number of concurrent calls.

<item><tt/RTPPortRange=50000-59999/<newline>
Default: <tt/10000-59999/
<p>
Specify the range of UDP port number for RTP/RTCP channels.
Note the range size may limit the number of concurrent calls.

<item><tt/ProxyForNAT=1/<newline>
Default: <tt/1/
<p>
If yes, the gatekeeper will proxy for calls to which one of the endpoints
participated is behind an NAT box. This ensure the RTP/RTCP stream can
penetrate into the NAT box without modifying it.
However, the endpoint behind the NAT box must use the same port
to send and receive RTP/RTCP stream.
If you have bad or broken endpoints that don't satisfy the precondition,
you have better to disable this feature and let the NAT box forward
RTP/RTCP stream for you.

<item><tt/ProxyForSameNAT=0/<newline>
Default: <tt/0/
<p>
Whether to proxy for calls between endpoints from the same NAT box.
You do not need to enable this feature in general, since usually endpoints
from the same NAT box can communicate with each other.
</itemize>

<sect2>Section &lsqb;RoutingPolicy&rsqb;
<label id="routingpolicy">
<p>
This section explains how the various possible routing
policies within the gatekeeper work.

The incoming call requests can be routed using a number
of routing providers:

<itemize>

<item><tt/explicit/<newline>
<p>
The destination is explicitly specified in the routing
request.

<item><tt/internal/<newline>
<p>
The classical rule; search the destination in
RegistrationTable

<item><tt/parent/<newline>
<p>
Route the call using information sent by the parent GK in
reply to an ARQ the gatekeeper will send.

<item><tt/neighbor/<newline>
<p>
Route the call using neighbors by exchanging LRQ messages

<item><tt/dns/<newline>
<p>
The destination is resolved from DNS, provided it is
resolvable

<item><tt/vqueue/<newline>
<p>
Use the virtual queue mechanism and generate a RouteRequest
event to let an external application do the routing
(can only be used OnARQ)

</itemize>

If one policy does not match, the next policy is tried.

These policies can be applied to a number of routing request types,
and routing input data. The different types are:
ARQ, LRQ, Setup and Facility (with the callForwarded reason)
There is also the general routing policy, which is kind of a
default for the other types.

<descrip>
<tag/Example:/
<quote><tt>[RoutingPolicy]<newline>
h323_ID=dns,internal<newline>
002=neighbor,internal<newline>
Default=internal,neighbor,parent</tt></quote>
</descrip>

When one of the messages is received which calls for a routing
decision, all calls to an alias of the h323_ID type will be
resolved using DNS. If DNS fails to resolve the alias, it is
matched against the internal registration table. If a call is
requested to an alias starting with 002, first the neighbours
are checked and then the internal registration table. If the
requested alias is not an h323_ID or an alias starting with
002, the default policy is used by querying the internal
registration table, then the neighbours, and if that fails the
parent.

For the ARQ, LRQ, Setup and Facility messages one would use the
[RoutingPolicy::OnARQ], [RoutingPolicy::OnLRQ],
[RoutingPolicy::OnSetup] and [RoutingPolicy::OnFacility] sections
using the syntax explained above.

<sect2>Section &lsqb;GkStatus::Auth&rsqb;
<p>
Define a number of rules who is allowed to connect to the status port.
Whoever has access to the status port has full control over your gatekeeper. Make sure this is set correctly.
<itemize>
<item><tt/rule=allow/<newline>
Default: <tt/forbid/
<p>
Possible values are
<itemize>
<item><tt/forbid/ - disallow any connection.
<item><tt/allow/ - allow any connection
<item><tt/explicit/ - reads the parameter <tt>ip=value</tt>
where <tt/ip/ is the IP address of the peering client,
<tt/value/ is <tt/1,0/ or <tt/allow,forbid/ or <tt/yes,no/.
If <tt/ip/ is not listed the parameter <tt/default/ is used.
<item><tt/regex/ - the IP of the client is matched against the given regular expression.
<p><descrip>
<tag/Example:/
To allow client from 195.71.129.0/24 and 195.71.131.0/24:
<quote><tt>regex=^195\.71\.(129|131)\.[0-9]+$</tt></quote>
</descrip>
<item><tt/password/ - the user has to input appropriate username and password to login. The format of username/password is the same as <ref id="password" name="[SimplePasswordAuth]"> section.

</itemize>

Moreover, these rules can be combined by "|" or "&amp;". For example,
<itemize>
<item><tt>rule=explicit | regex</tt><newline>
The IP of client must match <tt/explicit/ <bf/or/ <tt/regex/ rule.
<p>
<item><tt>rule=regex & password</tt><newline>
The IP of client must match <tt/regex/ rule, <bf/and/ the user has to login by username and password.
</itemize>

<item><tt/default=allow/<newline>
Default: <tt/forbid/
<p>
Only used when <tt/rule=explicit/.

<item><tt/Shutdown=forbid/<newline>
Default: <tt/allow/
<p>
Whether to allow shutdown the gatekeeper via status port.

<item><tt/DelayReject=5/<newline>
Default: <tt/0/
<p>
How long (in seconds) to wait before rejecting invalid username/password
for the status line access.
</itemize>

<sect2>Section &lsqb;RasSrv::GWPrefixes&rsqb;
<p>
This section lists what E.164 numbers are routed to a specific gateway.

<descrip>
<tag/Format:/
<tt>gw-alias=prefix[,prefix,...]</tt>
<p>
Note you have to specify the alias of the gateway.
If a gateway registered with the alias, all numbers beginning with
the prefixes are routed to this gateway.
<tag/Example:/
<tt/test-gw=02,03/
</descrip>

<sect2>Section &lsqb;RasSrv::RewriteE164&rsqb;
<label id="rewrite">
<p>
This section defines the rewriting rules for dialedDigits (E.164 number).

<descrip>
<tag/Format:/
<tt>[!]original-prefix=target-prefix[,target-prefix,...]</tt>
<p>
If the number is beginning with <tt/original-prefix/,
it is rewritten to <tt/target-prefix/. Multi targets are possible.
If the `<tt/!/' flag precedes the <tt/original-prefix/, the sense is inverted
and the target-prefix is prepended to the dialed number.
<tag/Example:/
<tt/08=18888/
<p>
If you dial <tt/08345718/, it is rewritten to <tt/18888345718/.
<tag/Example:/
<tt/!08=18888/
<p>
If you dial <tt/09345718/, it is rewritten to <tt/1888809345718/.
</descrip>

Option:
<itemize>
<item><tt/Fastmatch=08/<newline>
Default: <tt>N/A</tt>
<p>
Only rewrite dialDigits beginning with the specified prefix.
</itemize>

<sect2>Section &lsqb;RasSrv::GWRewriteE164&rsqb;
<label id="gwrewrite">
<p>
This section describes rewriting the dialedDigits E.164 number depending on
the gateway a call has come from or is being sent to. This allows for more
flexible manipulation of the dialedDigits for routing etc. In combination
with the <ref id="rewrite" name="RasSrv::RewriteE164"> you can have triple
stage rewriting:

<tscreen><verb>
Call from "gw1", dialedDigits 0867822
		|
		|
		V
Input rules for "gw1", dialedDigits now 550867822
		|
		|
		V
Global rules, dialedDigits now 440867822
		|
		|
		V
Gateway selection, dialedDigits now 440867822, outbound gateway "gw2"
		|
		|
		V
Output rules for "gw2", dialedDigits now 0867822
		|
		|
		V
Call to "gw2", dialedDigits 0867822
</verb></tscreen>

<descrip>
<tag/Format:/
<tt>gw-alias=in|out=[!]original-prefix=target-prefix[;in|out...]</tt>
<p>
If the call matches the gateway, the direction and begins with
<tt/original-prefix/ it is rewritten to <tt/target-prefix/.
If the `<tt/!/' flag precedes the <tt/original-prefix/, the sense is inverted.
Multiple rules for the same gateway should be seperated by ';'.
<tag/Example:/
<tt/gw1=in=123=321/
<p>
If a call is received from "gw1" to <tt/12377897/, it is rewritten to <tt/32177897/
before further action is taken.
</descrip>

<sect2>Section &lsqb;RasSrv::PermanentEndpoints&rsqb;
<p>
In this section you can put endpoints that don't have RAS support
or that you don't want to be expired. The records will always
keep in registration table of the gatekeeper.
However, You can still unregister it via status port.

<descrip>
<tag/Format:/
<tt>IP[:port]=alias[,alias,...;prefix,prefix,...]</tt>
<tag/Example:/
For gateway,
<quote/<tt/10.0.1.5=Citron;009,008//
For terminal,
<quote/<tt/10.0.1.10:1720=700//
</descrip>

<sect2>Section &lsqb;RasSrv::Neighbors&rsqb;
<label id="neighbor">
<p>
If the destination of an ARQ is unknown, the gatekeeper sends LRQs to
its neighbors to ask if they have the destination endpoint.
A neighbor is selected if one of its prefixes matches the destination
or it has ``<tt/*/'' prefix. More than one prefix can be specified.

Conversely, the gatekeeper will only reply to LRQs sent from neighbors
defined in this section.
If you specify an empty prefix, no LRQ will be sent to that neighbor,
but the gatekeeper will accept LRQs from it. By the empty prefix it is meant
a single semicolon appended to the neighbor entry. Example:<newline>
<newline>
<tt/	GK1=192.168.0.5;/<newline>
<newline>
If you skip the semicolon, LRQs will be always sent to this neighbor.

The <tt/password/ field is used to authenticate LRQs from that neighbor.
See section <ref id="gkauth" name="[Gatekeeper::Auth]"> for details.

Neighbor handling has changed significantly from version 2.0 to version 2.2.
Neighbors can be specified now in two ways - the old one and the new one.

<descrip>
<tag/Entry in the old format:/
<tt>GKID=ip[:port;prefixes;password;dynamic]</tt>
<p>
<tag/Example:/
<tt/GK1=192.168.0.5;*/<newline>
<tt/GK2=10.0.1.1:1719;035,036;gk2/<newline>
<tt/GK3=gk.citron.com.tw;;gk3;1/
</descrip>

<descrip>
<tag/Entry in the new format:/
<tt>GKID="GnuGK" | "CiscoGK" | "ClarentGK" | "GlonetGK"</tt>
<p>
<tag/Example:/
<tt/[RasSrv::Neighbors]/<newline>
<tt/GK1=CiscoGK/<newline>
<tt/GK2=GnuGK/<newline>
<newline>
<tt/[Neighbor::GK1]/<newline>
<tt/GatekeeperIdentifier=GK1/<newline>
<tt/Host=192.168.1.1/<newline>
<tt/SendPrefixes=02/<newline>
<tt/AcceptPrefixes=*/<newline>
<tt/ForwardLRQ=always/<newline>
<newline>
<tt/[Neighbor::GK2]/<newline>
<tt/GatekeeperIdentifier=GK2/<newline>
<tt/Host=192.168.1.2/<newline>
<tt/SendPrefixes=03,0048/<newline>
<tt/AcceptPrefixes=0049,001/<newline>
<tt/ForwardHopCount=2/<newline>
<tt/ForwardLRQ=depends/<newline>
<newline>
</descrip>

The new format specifies in <tt/[RasSrv::Neighbors]/ section only gatekeeper
types and configuration for each neighbor is placed in a separate section.

<sect2>Section &lsqb;RasSrv::LRQFeatures&rsqb;
<p>
Defines some features of LRQ and LCF.
<itemize>
<item><tt/NeighborTimeout=1/<newline>
Default: <tt/2/
<p>
Timeout value in seconds to wait responses from neighbors.
If no response from all neighbors after timeout, the gatekeeper will
reply an ARJ to the endpoint sending the ARQ.

<item><tt/ForwardHopCount=2/<newline>
Default: <tt>N/A</tt>
<p>
If the gatekeeper receives an LRQ that the destination is either unknown,
it may forward this message to its neighbors.
When the gatekeeper receives an LRQ and decides that the message
should be forwarded on to another gatekeeeper, it first decrements
<bf/hopCount/ field of the LRQ.
If <bf/hopCount/ has reached 0, the gatekeeper shall not forward the message.
This options defines the number of gatekeepers through which an LRQ
may propagate. Note it only affects the sender of LRQ, not the forwarder.
This setting can be overriden with configuration of a particular neighbor.

<item><tt/AlwaysForwardLRQ=1/<newline>
Default: <tt>0</tt>
<p>
Force the gatekeeper to forward an LRQ even if there is no <bf/hopCount/
in the LRQ. To avoid LRQ loops, you should use this option very carefully.
This option is used only for an old-style (2.0) neighbor configuration,
the new one reads the settings from a neighbor-specific config section.

<item><tt/AcceptForwardedLRQ=1/<newline>
Default: <tt/1/
<p>
Whether to accept an LRQ forwarded from neighbors.
This setting can be overriden with configuration
of a particular neighbor.

<item><tt/IncludeDestinationInfoInLCF=0/<newline>
Default: <tt/1/
<p>
The gatekeeper replies LCFs containing <bf/destinationInfo/ and
<bf/destinationType/ fields, the aliases and terminal type of the destination
endpoint. The neighbor gatekeeper can then save the information to suppress
later LRQs. However, some vendors' gatekeepers misuse the information, thus
result in interoperability problems.
Only turn off this option if you encounter problems upon communicating
with a third-party gatekeeper.

<item><tt/ForwardResponse=0/<newline>
Default: <tt/0/
<p>
If the gatekeeper forwards received LRQ message it can decide either
to receive the LCF response or to let it travel back directly to the LRQ
origintator. Set this option to 1, if the gatekeeper needs to receive LCF
messages for forwarded LRQs. This setting can be overriden with configuration
of a particular neighbor.

<item><tt/ForwardLRQ=always | never | depends/<newline>
Default: <tt/depends/
<p>
This settings determines whether the received LRQ should be forwarded
or not. <tt/always/ forwards LRQ unconditionally, <tt/never/ blocks LRQ
forwarding, <tt/depends/ tells the gatekeeper to forward LRQ only if its
hop count is greater than 1. This setting can be overriden with configuration
of a particular neighbor.
</itemize>

<sect3>Section &lsqb;Neighbor::...&rsqb;
<p>
Sections starting with <tt/[Neighbor::/ are for neighbor specific configuration.

<itemize>
<item><tt/GatekeeperIdentifier=GKID/<newline>
Default: <tt>N/A</tt>
<p>
Gatekeeper identifier for this neighbor. If this options is not specified,
the identifier is taken from the second part of this <tt/Neighbor::/ section name.

<item><tt/Host=192.168.1.1/<newline>
Default: <tt>N/A</tt>
<p>
An IP address for this neighbor.

<item><tt/Password=secret/<newline>
Default: <tt>N/A</tt>
<p>
A password to be used to validate crypto tokens received from incoming LRQs.
<tt/It is not yet implemented/.

<item><tt/Dynamic=0/<newline>
Default: <tt>0</tt>
<p>
1 means that the IP address for this neighbor can change.

<item><tt/SendPrefixes=004,002:=1,001:=2/<newline>
Default: <tt>N/A</tt>
<p>
A list of prefixes that this neighbor expects LRQs to receive for.
If '*' is specified, LRQs will always be sent to this neighbor.
A priority can be given to each prefix for each neighbor (using := syntax),
so in case of multiple LCF received from multiple neighbor, the one
with the highest priority will be selected to route the call.
One can also direct the gatekeeper to send LRQ to this neighbor
based on an alias type:<newline>
SendPrefixes=h323_ID,dialedDigits,001<newline>

<item><tt/AcceptPrefixes=*/<newline>
Default: <tt>*</tt>
<p>
A list of prefixes that the gatekeeper will accept in LRQs received
from this neighbor. If '*' is specified, all LRQs will be accepted from this neighbor.
One can also direct the gatekeeper to accept LRQ from this neighbor
based on an alias type:<newline>
AcceptPrefixes=dialedDigits<newline>

<item><tt/ForwardHopCount=2/<newline>
Default: <tt>N/A</tt>
<p>
If the gatekeeper receives an LRQ that the destination is either unknown,
it may forward this message to its neighbors.
When the gatekeeper receives an LRQ and decides that the message
should be forwarded on to another gatekeeeper, it first decrements
<bf/hopCount/ field of the LRQ.
If <bf/hopCount/ has reached 0, the gatekeeper shall not forward the message.
This options defines the number of gatekeepers through which an LRQ
may propagate. Note it only affects the sender of LRQ, not the forwarder.

<item><tt/AcceptForwardedLRQ=1/<newline>
Default: <tt/1/
<p>
Whether to accept an LRQ forwarded from this neighbor.

<item><tt/ForwardResponse=0/<newline>
Default: <tt/0/
<p>
If the gatekeeper forwards received LRQ message it can decide either
to receive the LCF response or to let it travel back directly to the LRQ
origintator. Set this option to 1, if the gatekeeper needs to receive LCF
messages for forwarded LRQs.

<item><tt/ForwardLRQ=always | never | depends/<newline>
Default: <tt/depends/
<p>
This settings determines whether the received LRQ should be forwarded
or not. <tt/always/ forwards LRQ unconditionally, <tt/never/ blocks LRQ
forwarding, <tt/depends/ tells the gatekeeper to forward LRQ only if its
hop count is greater than 1. This setting can be overriden with configuration
of a particular neighbor.

</itemize>

<sect2>Section &lsqb;RasSrv::RRQFeatures&rsqb;
<p>
<itemize>
<item><tt/AcceptEndpointIdentifier=1/<newline>
Default: <tt/1/
<p>
Whether to accept <bf/endpointIdentifier/ specified in a full RRQ.

<item><tt/AcceptGatewayPrefixes=1/<newline>
Default: <tt/1/
<p>
A gateway can register its prefixes with the gatekeeper by containing
<bf/supportedPrefixes/ in the <bf/terminalType/ field of RRQ.
This option defines whether to accept the specified prefixes of a gateway.

<item><tt/OverwriteEPOnSameAddress=1/<newline>
Default: <tt/0/
<p>
In some networks an endpoint's IP address may change unexpectedly.  This
may happen when an endpoint is using a PPP connection (e.g. modem or ADSL).
This option defines how to handle a registration request (RRQ) from an IP
address which does not match what we have stored.  The default action is
to reject the request.  With this option enabled the conflicting request
will cause an unregister request (URQ) to be sent for the existing IP
address and the entry to be removed allowing the endpoint to register
with the new address.
</itemize>

<sect2>Section &lsqb;RasSrv::ARQFeatures&rsqb;
<p>
<itemize>
<item><tt/ArjReasonRouteCallToSCN=0/<newline>
Default: <tt/1/
<p>
If yes, the gatekeeper rejects a call from a gateway to itself by reason
<bf/routeCallToSCN/.

<item><tt/ArjReasonRouteCallToGatekeeper=1/<newline>
Default: <tt/1/
<p>
If yes, the gatekeeper rejects an answered ARQ without a pre-existing
CallRec found in the CallTable by reason <bf/routeCallToGatekeeper/
in routed mode.
The endpoint shall release the call immediately and re-send call Setup
to the gatekeeper.

<item><tt/CallUnregisteredEndpoints=0/<newline>
Default: <tt/1/
<p>
With this option set on, the gatekeeper will accept an ARQ from a registered
endpoint with <bf/destCallSignalAddress/, no matter the address is belongs
to a registered endpoint or not.
That means you can explicitly specify the IP of endpoint (registered or not)
you want to call.

<item><tt/RemoveTrailingChar=#/<newline>
Default: <tt>N/A</tt>
<p>
Specify the trailing character to be removed in <bf/destinationInfo/.
For example, if your endpoint incorrectly contains the termination character
like `&num;' in <bf/destinationInfo/, you may remove it by this option.

<item><tt/RoundRobinGateways=0/<newline>
Default: <tt/1/
<p>
Enable/disable round-robin gateway selection, if more than one gateway
matches a dialed number. If disabled, the first available gateway will be selected.
Otherwise, subsequent calls will be sent to gateways in round-robin fashion.

</itemize>

<sect2>Section &lsqb;CallTable&rsqb;
<label id="calltable">
<p>
<itemize>
<item><tt/GenerateNBCDR=0/<newline>
Default: <tt/1/
<p>
Generate CDRs for calls from neighbor zones.
The IP and endpoint ID of the calling party is printed as empty.
This is usually used for debug purpose.

<item><tt/GenerateUCCDR=0/<newline>
Default: <tt/0/
<p>
Generate CDRs for calls that are unconnected. This is usually
used for debug purpose. Note a call is considered unconnected
only if the gatekeeper uses routed mode and a Q.931 Connect message is not
received by the gatekeeper. In direct mode, a call is always considered
connected.

<item><tt/DefaultCallDurationLimit=3600/<newline>
Default: <tt/0/
<p>
Default maximum call duration limit (seconds).
Set it to <tt/0/ to disable this feature and not limit
calls duration.

<item><tt/AcctUpdateInterval=60/<newline>
Default: <tt/0/
<p>
A time interval (seconds) for accounting updates to be logged
for each call in progress. The exact details of the accounting updates
depend on accounting logger modules selected (see section
<ref id="gkacct" name="[Gatekeeper::Acct]">). In general, the accounting
update is to provide backend services with incrementing call duration
for connected calls.
The default value 0 tells the gatkeeper to not send accounting updates
at all. Please note that setting short periods may decrease GK performance.

<item><tt/TimestampFormat=Cisco/<newline>
Default: <tt/RFC822/
<p>
Format of timestamp strings printed inside CDRs.

</itemize>


<sect2>Section &lsqb;Endpoint&rsqb;
<p>
The gatekeeper can work as an endpoint by registering with another gatekeeper.
With this feature, you can easily build gatekeeper hierarchies.
The section defines the endpoint features for the gatekeeper.

<itemize>
<item><tt/Gatekeeper=10.0.1.1/<newline>
Default: <tt/no/
<p>
Define a parent gatekeeper for the endpoint(gatekeeper) to register with.
Don't try to register with yourself, unless you want to be confusing.
To disable this feature, set the field to be <tt/no/.

<item><tt/Type=Gateway/<newline>
Default: <tt/Gateway/
<p>
Define the terminal type for the endpoint.
The valid values are <tt/Gateway/ or <tt/Terminal/.

<item><tt/H323ID=CitronProxy/<newline>
Default: <tt>&lt;Name&gt;</tt>
<p>
Specify the H.323 ID aliases for the endpoint.
Multiple aliases can be separated by comma.

<item><tt/E164=18888600000,18888700000/<newline>
Default: <tt>N/A</tt>
<p>
Define the E.164 (dialedDigits) aliases for the endpoint.
Multiple aliases can be separated by comma.

<item><tt/Password=123456/<newline>
Default: <tt>N/A</tt>
<p>
Specify a password to be sent to the parent gatekeeper.
All RAS requests will contain the password in the <bf/cryptoTokens/ field
(MD5 & HMAC-SHA1-96) and the <bf/tokens/ field (CAT).
To send RAS requests without both <bf/cryptoTokens/ and <bf/tokens/ fields,
set the password to be empty.
<p>
Besides, the password is also used in LRQs sent to neighbor gatekeepers.

<item><tt/Prefix=188886,188887/<newline>
Default: <tt>N/A</tt>
<p>
Register the specified prefixes with the parent gatekeeper.
Only takes effect when the Type is <tt/Gateway/.

<item><tt/TimeToLive=900/<newline>
Default: <tt>60</tt>
<p>
Suggest a time-to-live value in seconds for the registration.
Note that the real time-to-live timer is assigned by the parent
gatekeeper in the RCF replied to the RRQ.

<item><tt/RRQRetryInterval=10/<newline>
Default: <tt/3/
<p>
Define a retry interval in seconds for resending an RRQ if no response 
is received from the parent gatekeeper. This interval is doubled with each
failure, up to a maximum RRQRetryInterval * 128 timeout.

<item><tt/ARQTimeout=2/<newline>
Default: <tt/2/
<p>
Define the timeout value in second for ARQs.

<item><tt/UnregisterOnReload=1/<newline>
Default: <tt/0/
<p>
Defines whether the child gatekeeper unregisters and re-registers with
it's parent when receiving a Reload command.

<item><tt/NATRetryInterval=60/<newline>
Default: <tt/60/
<p>
How long to wait before trying to reconnect TCP NAT signalling socket (seconds).
This can happen when either the connection cannot be established or it has
been broken.

<item><tt/NATKeepaliveInterval=86400/<newline>
Default: <tt/86400/
<p>
Define how often the TCP NAT signalling connection with a parent gatekeeper
is refreshed. As NAT boxes usually keep TCP mappings for a definite time only,
it is good to set this to some value a bit shorter than NAT box mapping timeout.
Refreshing is done by sending a special Q.931 IncomingCallProceeding message.
If you NAT performs TCP port translation, you may need to set it to a values
as short as 60 seconds.

<item><tt/Discovery=0/<newline>
Default: <tt/1/
<p>
Decide whether to discover the parent gatekeeper by sending GRQ first.

<item><tt/UseAlternateGK=0/<newline>
Default: <tt/1/
<p>
Enable alternate gatekeepers feature. If GRJ/GCF/RFC messages received 
from a parent gatekeeper contain a list of alternate gatekeepers, this
information is stored and can be used to reregister with another gatekeeper
in case of any failure. If you don't want to use this feature, set this
variable to <tt/0/.

<item><tt/GatekeeperIdentifier=ParentGK/<newline>
Default: <tt/Not set/
<p>
Define it if you want to accept only such parent gatekeepers that match
this gatekeeper identifier. Useful with GRQ discovery and can prevent 
an accidental gatekeeper match. Do not set this variable, if you do not
care about gatekeeper identifiers or you use alternate gatekeepers that
can have different gatekeeper indentifiers set.

<item><tt/EndpointIdentifier=OpenH323GK/<newline>
Default: <tt/Not set/
<p>
Set this if you want to use a specific endpoint identifier for this child
gatekeeper. If this option is not set (default), the identifier is assigned
by a parent gatekeeper in a GCF/RCF message.

</itemize>


<sect2>Section &lsqb;Endpoint::RewriteE164&rsqb;
<p>
Once you specify prefix(es) for your gatekeeper endpoint, the parent
gatekeeper will route calls with <bf/dialedDigits/ beginning with that prefixes.
The child gatekeeper can rewrite the destination according to the rules
specified in this section. By contrast, when an internal endpoint calls
an endpoint registered to the parent gatekeeper, the source will be
rewritten reversely.

<descrip>
<tag/Format:/
<tt/external prefix=internal prefix/
</descrip>

For example, if you have the following configuration,

<tscreen><verb>
                        [Parent GK]
                        ID=CitronGK
                        /         \
                       /           \
                      /             \
                     /               \
                [Child GK]          [EP3]
                ID=ProxyGK          E164=18888200
                Prefix=188886
                /       \
               /         \
              /           \
           [EP1]         [EP2]
           E164=601      E164=602
</verb></tscreen>

With this rule:
<tscreen><verb>
188886=6
</verb></tscreen>

When EP1 calls EP3 by <tt/18888200/, the CallingPartyNumber in the Q.931 Setup
will be rewritten to <tt/18888601/. Conversely, EP3 can reach EP1 and EP2
by calling <tt/18888601/ and <tt/18888602/, respectively. In consequence, an
endpoint registered to the child GK with prefix '<tt/6/' will appear
as an endpoint with prefix '<tt/188886/', for endpoints registered to
the parent gatekeeper.

The section does not relate to the section
<ref id="rewrite" name="RasSrv::RewriteE164">,
though the later will take effect first.

<sect2>Section &lsqb;Gatekeeper::Auth&rsqb;
<label id="gkauth">
<p>
The section defines the authentication mechanism for the gatekeeper.

<descrip>
<tag/Syntax:/
<tscreen><verb>
authrule=actions

 <authrule> := SimplePasswordAuth | AliasAuth | PrefixAuth | RadAuth | RadAliasAuth | ...
 <actions>  := <control>[;<ras>|<q931>,<ras>|<q931>,...]
 <control>  := optional | required | sufficient
 <ras>      := GRQ | RRQ | URQ | ARQ | BRQ | DRQ | LRQ | IRQ
 <q931>     := Setup | SetupUnreg

</verb></tscreen>
</descrip>
A rule may results in one of the three codes: ok, fail, pass.
<itemize>
<item><tt/ok/ - The request is authenticated by this module.
<item><tt/fail/ - The authentication fails and should be rejected.
<item><tt/next/ - The rule cannot determine the request.
</itemize>
There are also three ways to control a rule:
<itemize>
<item><tt/optional/ - If the rule cannot determine the request, it is passed to next rule.
<item><tt/required/ - The requests should be authenticated by this module, or it would be rejected. The authenticated request would then be passwd to next rule.
<item><tt/sufficient/ - If the request is authenticated, it is accepted, or it would be rejected. That is, the rule determines the fate of the request. No rule should be put after a sufficient rule, since it won't take effect.
</itemize>

Currently supported modules:
<itemize>
<item><tt>SimplePasswordAuth/SQLPasswordAuth/LDAPPasswordAuth</tt>
<p>
These modules check the <bf/tokens/ or <bf/cryptoTokens/ fields of RAS message.
The tokens should contain at least generalID and password.
For <bf/cryptoTokens/, <bf/cryptoEPPwdHash/ tokens hashed by simple MD5 and
<bf/nestedcryptoToken/ tokens hashed by HMAC-SHA1-96 (libssl must be installed!)
are supported now. For <bf/tokens/ tokens hashed by CAT (Cisco Access Token)
and a clear text username/password are supported now.
The ID and password are read from <ref id="password" name="[SimplePasswordAuth]"> section,
an SQL database or LDAP
for <tt/SimplePasswordAuth/, <tt/SQLPasswordAuth/ and <tt/LDAPPasswordAuth/
modules, respectively. <tt/MySQLPasswordAuth/
module is supported for backward compatibility.

<item><tt>AliasAuth/SQLAliasAuth/LDAPAliasAuth</tt>
<p>
The module can only be used to authenticate RegistrationRequest (RRQ).
The IP of an endpoint with a given alias should match a specified pattern.
For <tt/AliasAuth/ the pattern is defined in
<ref id="rrqauth" name="[RasSrv::RRQAuth]"> section.
For <tt/SQLAliasAuth/, the pattern is retrieved from an SQL database, 
defined in <ref id="sqlaliasauth" name="[SQLAliasAuth]"> section.
For <tt/LDAPAliasAuth/ the alias (default: mail attribute) and IP
(default: voIPIpAddress attribute) must be found in one LDAP entry.
Support for <tt/MySQLAliasAuth/ is maintained for backward compatibility.

<item><tt>PrefixAuth</tt>
<p>
Originally known as <tt/GkAuthorize/.
The IP or aliases of a request with a given prefix must match a specified
pattern. See section <ref id="prefixauth" name="[PrefixAuth]"> for details.
Currently the module can only authorize
AdmissionRequest (ARQ) and LocationRequest (LRQ).

<item><tt>RadAuth</tt>
<p>
Provides authentication based on H.235 username/password
security scheme. Authenticates RRQ, ARQ and Q.931 Setup through remote
RADIUS servers. It passes to RADIUS servers usernames and passwords
extracted from CAT (Cisco Access Tokens) <bf/tokens/ carried
inside RRQ, ARQ or Setup packets. Therefore if your endpoints do not
support CATs or you do not need authentication scheme based on
individually assigned usernames/password - this module will not
work for you (but you may check <tt/RadAliasAuth/ module).
See section <ref id="radauth" name="[RadAuth]"> for details.

<item><tt>RadAliasAuth</tt>
<p>
Provides authentication based on endpoint aliases
and/or call signalling IP addresses with remote RADIUS servers.
It does not need any H.235 <bf/tokens/ inside RAS messages,
so it can be used on a wider range of systems as compared to <tt/RadAuth/.
RRQ, ARQ and Q.931 Setup messages can be authenticated using this module.
See section <ref id="radaliasauth" name="[RadAliasAuth]"> for details.

</itemize>

You can also configure a rule to check only for some particular RAS messages.
The following example configures <tt/SimplePasswordAuth/ as an optional rule
to check RRQ and ARQ. If an RRQ is not checked (not contains
<bf/tokens/ or <bf/cryptoTokens/ fields), it is checked by <tt/AliasAuth/.
The default is to accept all requests.

<descrip>
<tag/Example 1:/
<tt/SimplePasswordAuth=optional;RRQ,ARQ/<newline>
<tt/AliasAuth=sufficient;RRQ/<newline>
</descrip>

The example below authenticates all calls, checking signalling Setup
message details, using RadAliasAuth module.

<descrip>
<tag/Example 2:/
<tt/RadAliasAuth=required;Setup/<newline>
<tt/default=allow/
</descrip>

This example checks endpoint registrations (RRQ) and call admissions (ARQ)
either by means of username/password (RadAuth) or alias/IP (RadAliasAuth).
Additionally, if the call is from an unregistered endpoint (and therefore
no RRQ or ARQ authentication has been performed), Setup message authentication
using RadAliasAuth takes place (SetupUnreg).

<descrip>
<tag/Example 3:/
<tt/RadAuth=optional;RRQ,ARQ/<newline>
<tt/RadAliasAuth=required;RRQ,ARQ,SetupUnreg/<newline>
<tt/default=allow/
</descrip>

<sect2>Section &lsqb;SimplePasswordAuth&rsqb;
<label id="password">
<p>
The section defines the userid and password pairs used by
<tt/SimplePasswordAuth/ module.
Use `<tt/make addpasswd/' to generate the utility <tt/addpasswd/.

Usage:
<tscreen><verb>
addpasswd config userid password
</verb></tscreen>

Options:
<itemize>
<item><tt/KeyFilled=123/<newline>
Default: <tt/0/
<p>
Default value to initialize the encryption key.

<item><tt/CheckID=1/<newline>
Default: <tt/0/
<p>
Check if the aliases match the ID in the tokens.

<item><tt/PasswordTimeout=120/<newline>
Default: <tt/-1/
<p>
The module <tt/SimplePasswordAuth/ and all its descendants will cache an
authenticated password. This field define the cache timeout value in second.
<tt/0/ means never cache the password, while a negative value
means the cache never expires.
</itemize>

<sect2>Section &lsqb;SQLPasswordAuth&rsqb;
<label id="sqlpasswordauth">
<p>
Authenticate H.235 enabled endpoints using passwords stored
in the SQL database. This section defines SQL driver to use,
SQL database connection parameters and the query to use to retrieve passwords.

<itemize>
<item><tt/Driver=MySQL | PostgreSQL/<newline>
Default: N/A
<p>
SQL database driver to use. Currently, <tt/MySQL/ and <tt/PostgreSQL/ drivers
are implemented.

<item><tt/Host=DNS[:PORT] | IP[:PORT][;DNS[:PORT] | IP[:PORT]].../<newline>
Default: <tt/localhost/
<p>
SQL server host address. Can be in the form of <tt/DNS[:PORT]/ or <tt/IP[:PORT]/.
Like <tt/sql.mycompany.com/ or <tt/sql.mycompany.com:3306/ or <tt/192.168.3.100/.
Multiple hosts, separated by the semicolon, may be specified to support failover.

<item><tt/Database=billing/<newline>
Default: <tt/billing/
<p>
The database name to connect to.

<item><tt/Username=gnugk/<newline>
<p>
The username used to connect to the database.

<item><tt/Password=secret/<newline>
<p>
The password used to connect to the database.
If the password is not specified, a database connection attempt 
without any password will be made.

<item><tt/CacheTimeout=120/<newline>
Default: <tt/0/
<p>
This field defines how long (alias;password) pairs retrieved from the database 
will be cached in the local memory. The cache timeout value is expressed in seconds.
<tt/0/ means to not cache passwords, while a negative value
means the cache never expires (only <tt/reload/ command will refresh the cache).

<item><tt/MinPoolSize=5/<newline>
Default: <tt/1/
<p>
Define the number of active SQL connections. This allows better peformance
under heave load, because more than 1 concurrent query can be executed 
at the same time. <tt/MinPoolSize=1/ setting simulates old behaviour, 
when access to the SQL database is serialized (one query at time).

<item><tt/Query=SELECT .../<newline>
Default: <tt>N/A</tt>
<p>
Defines SQL query used to retrieve H.235 password from the database. The query
is parametrized - that means parameter replacement is made before each query
is executed. Parameter placeholders are denoted by <bf/%1/, <bf/%2/, ... strings.
Specify %% to embed a percent character before a digit into string (like <bf/%%1/),
specify <bf/%{1}/ to allow expansion inside complex expressions like <bf/%{1}123/.
For <tt/SQLPasswordAuth/ two parameters are defined:
<itemize>
<item><tt/%1/ - the actual alias to query the password for
<item><tt/%2/ - the gatekeeper identifier
</itemize>
<p>
Sample query strings:
<tscreen><verb>
SELECT h235password FROM users WHERE alias = '%1' AND active
SELECT h235password FROM users WHERE alias = '%1' AND gk = '%2'
</verb></tscreen>

</itemize>

<sect2>Section &lsqb;MySQLPasswordAuth&rsqb;
<p>
Define the MySQL database, table and fileds to retrieve the userid and password.
This is obsolete, use <ref id="sqlpasswordauth" name="[SQLPasswordAuth]"> instead.

<itemize>
<item><tt/Host=localhost/<newline>
Default: <tt/localhost/
<p>
Host name or IP of the MySQL server.

<item><tt/Port=5353/<newline>
Default: <tt/5353/
<p>
Port the MySQL server is listening on (if different for the default).

<item><tt/Database=billing/<newline>
Default: <tt/billing/
<p>
The database to connect.

<item><tt/User=cwhuang/<newline>
<item><tt/Password=123456/<newline>
<p>
The user name and password used to connect to the database.

<item><tt/Table=customer/<newline>
<p>
The table in the database to query.

<item><tt/KeyField=IPN/<newline>
<p>
A name for the column that contains user alias.

<item><tt/DataField=Password/<newline>
<p>
A name for the column that contains user password.

<item><tt/ExtraCriterion=Kind > 0/<newline>
Default: <tt>N/A</tt>
<p>
Specify extra criterion.

<item><tt/CacheTimeout=30/<newline>
Default: <tt>0</tt>
<p>
Timeout value after username/password pairs cached in memory
will be refreshed from the database. Default is to not cache
passwords at all (CacheTimeout=0). -1 means the cache does not
expire - it will be refreshed only when the gatekeeper is reloaded.

</itemize>

The SQL command will be issused:
<tscreen><verb>
SELECT $DataField FROM $Table WHERE $KeyField = %id [AND $ExtraCriterion]
</verb></tscreen>

<sect2>Section &lsqb;RasSrv::RRQAuth&rsqb;
<label id="rrqauth">
<p>
Specify the action on RRQ reception (confirm or deny) for <tt/AliasAuth/ module.
The first alias (this will mostly be an H323ID) of the endpoint to
register is looked up in this section. If a parameter is found the value will
apply as a rule. A rule consists of conditions separated by "&".
A registration is accepted when all conditions apply.

<descrip>
<tag/Syntax:/
<tscreen><verb>
&lt;authrules&gt; :=  empty  |  &lt;authrule&gt; "&" &lt;authrules&gt;

  &lt;authrule&gt;  := &lt;authtype&gt; ":" &lt;authparams&gt;
  &lt;authtype&gt;  := "sigaddr" | "sigip"
  &lt;autparams&gt; := [!&]*
</verb></tscreen>
</descrip>

The notation and meaning of <tt/&lt;authparams&gt;/ depends on
<tt/&lt;authtype&gt;/:

<itemize>
<item><tt/sigaddr/ - extended regular expression that has to match agains the
``PrintOn(ostream)'' representation of the signal address of the request.
<p>
Example:
<tscreen><verb>
sigaddr:.*ipAddress .* ip = .* c0 a8 e2 a5 .*port = 1720.*
</verb></tscreen>

<item><tt/sigip/ - specialized form of `<tt/sigaddr/'.
Write the signalling ip adresse using (commonly used) decimal notation:
``<tt/byteA.byteB.byteC.byteD:port/''.
<p>
Example:
<tscreen><verb>
sigip:192.168.242.165:1720
</verb></tscreen>

<item><tt/allow/ - always accept the alias.

<item><tt/deny/ - always reject the alias.

</itemize>

<sect2>Section &lsqb;SQLAliasAuth&rsqb;
<label id="sqlaliasauth">
<p>
Authenticate endpoints using rules stored in the SQL database
(the rules conform to the format defined in the <ref id="rrqauth" name="[RasSrv::RRQAuth]"> section). 
This section defines SQL driver to use, SQL database connection parameters 
and the query to use to retrieve the patterns.

<itemize>
<item><tt/Driver=MySQL | PostgreSQL/<newline>
Default: N/A
<p>
SQL database driver to use. Currently, <tt/MySQL/ and <tt/PostgreSQL/ drivers
are implemented.

<item><tt/Host=DNS[:PORT] | IP[:PORT][;DNS[:PORT] | IP[:PORT]].../<newline>
Default: <tt/localhost/
<p>
SQL server host address. Can be in the form of <tt/DNS[:PORT]/ or <tt/IP[:PORT]/.
Like <tt/sql.mycompany.com/ or <tt/sql.mycompany.com:3306/ or <tt/192.168.3.100/.
Multiple hosts, separated by the semicolon, may be specified to support failover.

<item><tt/Database=billing/<newline>
Default: <tt/billing/
<p>
The database name to connect to.

<item><tt/Username=gnugk/<newline>
<p>
The username used to connect to the database.

<item><tt/Password=secret/<newline>
<p>
The password used to connect to the database.
If the password is not specified, a database connection attempt 
without any password will be made.

<item><tt/CacheTimeout=120/<newline>
Default: <tt/0/
<p>
This field defines how long (alias;authrule) pairs retrieved from the database 
will be cached in the local memory. The cache timeout value is expressed in seconds.
<tt/0/ means to not cache rules, while a negative value
means the cache never expires (only <tt/reload/ command will refresh the cache).

<item><tt/MinPoolSize=5/<newline>
Default: <tt/1/
<p>
Define the number of active SQL connections. This allows better peformance
under heave load, because more than 1 concurrent query can be executed 
at the same time. <tt/MinPoolSize=1/ setting simulates old behaviour, 
when access to the SQL database is serialized (one query at time).

<item><tt/Query=SELECT .../<newline>
Default: <tt>N/A</tt>
<p>
Defines SQL query used to retrieve alias rule from the database. The query
is parametrized - that means parameter replacement is made before each query
is executed. Parameter placeholders are denoted by <bf/%1/, <bf/%2/, ... strings.
Specify %% to embed a percent character before a digit into string (like <bf/%%1/),
specify <bf/%{1}/ to allow expansion inside complex expressions like <bf/%{1}123/.
For <tt/SQLAliasAuth/ two parameters are defined:
<itemize>
<item><tt/%1/ - the actual alias to query the rule for
<item><tt/%2/ - the gatekeeper identifier
</itemize>
<p>
Sample query strings:
<tscreen><verb>
SELECT authrule FROM users WHERE alias = '%1' AND active
SELECT 'sigip:' || host(ip) || port FROM users WHERE alias = '%1'
</verb></tscreen>

</itemize>

<sect2>Section &lsqb;MySQLAliasAuth&rsqb;
<label id="mysqlaliasauth">
<p>
Define the MySQL database, table and fileds to retrieve a pattern for an alias.
This section is OBSOLETE and provided only for backward compatibility. Please
use <ref id="sqlaliasauth" name="[SQLAliasAuth]"> instead.

<itemize>
<item><tt/Host=localhost/<newline>
Default: <tt/localhost/
<p>
Host name or IP of the MySQL server.

<item><tt/Port=5353/<newline>
Default: <tt/5353/
<p>
Port the MySQL server is listening on (if different for the default).

<item><tt/Database=billing/<newline>
Default: <tt/billing/
<p>
The database to connect.

<item><tt/User=cwhuang/<newline>
<item><tt/Password=123456/<newline>
<p>
The user name and password used to connect to the database.

<item><tt/Table=customer/<newline>
<p>
The table in the database to query.

<item><tt/KeyField=alias/<newline>
<p>
A name for the column that contains user alias.

<item><tt/DataField=IPADDR/<newline>
<p>
A name for the column that contains a AuthAlias rule. This can be an IP number or any other rule,
see section <ref id="rrqauth" name="[RasSrv::RRQAuth]">..

<item><tt/ExtraCriterion=Kind > 0/<newline>
Default: <tt>N/A</tt>
<p>
Specify extra criterion.

<item><tt/CacheTimeout=30/<newline>
Default: <tt>0</tt>
<p>
Timeout value after username/password pairs cached in memory
will be refreshed from the database. Default is to not cache
passwords at all (CacheTimeout=0). -1 means the cache does not
expire - it will be refreshed only when the gatekeeper is reloaded.

</itemize>

The SQL command will be issused:
<tscreen><verb>
SELECT $DataField FROM $Table WHERE $KeyField = %alias [AND $ExtraCriterion]
</verb></tscreen>

<sect2>Section &lsqb;PrefixAuth&rsqb;
<label id="prefixauth">
<p>
The section defines the authentication rule for <tt/PrefixAuth/ module.
Currently, only ARQs and LRQs can be authorized by this module.

First, a most specific prefix is selected according to the <bf/destinationInfo/
field of the received request. Then the request is accepted or rejected
according to the matched rules with most specific netmask.
If no matched prefix is found,
and the <tt/default/ option is specified, the request is accepted
or rejected according to that. Otherwise
it is rejected or passed to next authentication module
according to the module requirement.

<descrip>
<tag/Format:/
<tscreen><verb>
prefix=authrule[|authrule|...]
</verb></tscreen>

<tag/Syntax:/
<tscreen><verb>
&lt;authrule&gt; :=  &lt;result&gt; &lt;authrule&gt;

  &lt;result&gt;    := deny | allow
  &lt;authrule&gt;  := [!]ipv4:&lt;iprule&gt; | [!]alias:&lt;aliasrule&gt;
</verb></tscreen>
</descrip>
Where <tt/&lt;iprule&gt;/ can be specified in decimal dot notation or
CIDR notation, <tt/&lt;aliasrule&gt;/ is expressed in regular expression.
If the `<tt/!/' flag precedes the rule, the sense is inverted.

<descrip>
<tag/Example:/
<tscreen><verb>
555=deny ipv4:10.0.0.0/27|allow ipv4:0/0
5555=allow ipv4:192.168.1.1|deny ipv4:192.168.1.0/255.255.255.0
86=deny !ipv4:172.16.0.0/24
09=deny alias:^188884.*
ALL=allow ipv4:ALL
</verb></tscreen>
</descrip>

In this configuration, all endpoints except from network <tt>10.0.0.0/27</tt>
are allow to call prefix 555 (except 5555).
Endpoints from <tt>192.168.1.0/24</tt> are not allowed to call prefix 5555,
except <tt/192.168.1.1/.
Endpoints <bf/not/ from <tt>172.16.0.0/24</tt> are denied to call prefix 86.
Endpoints having an alias beginning with 188884 are not allowed to call
prefix 09. All other situations are allowed.

<sect2>Section &lsqb;RadAuth&rsqb;
<label id="radauth">
<p>
This section defines configuration settings that enable
RADIUS authentication based on H.235 CATs (Cisco Access Tokens)
present in RRQ, ARQ RAS requests and Q.931 Setup messages.
<itemize>
<item><tt/Servers=SERVER1[:AUTH_PORT[:ACCT_PORT[:SECRET]]];SERVER2[:AUTH_PORT[:ACCT_PORT[:SECRET]]];.../<newline>
Default: <tt>N/A</tt>
<p>
RADIUS servers to be used for authentication. The list can contain an arbitrary 
number of servers. The order of servers is important, because servers will 
be queried by the RADIUS module in the given order. If no port information 
is provided, port number from <tt/DefaultAuthPort/ will be used. If no secret is set, 
the default shared secret from <tt/SharedSecret/ is taken. 
Servers names can be IP addresses or DNS names.

<descrip>
<tag>Sample <tt/Servers/ lines:</tag>
<tt>Servers=192.168.1.1</tt><newline>
<tt>Servers=192.168.1.1:1645</tt><newline>
<tt>Servers=192.168.1.1:1645:1646:secret1</tt><newline>
<tt>Servers=radius1.mycompany.com:1812</tt><newline>
<tt>Servers=radius1.mycompany.com;radius2.mycompany.com</tt><newline>
<tt>Servers=radius1.mycompany.com:1812:1813:secret1;radius2.mycompany.com:1812:1813:secret2</tt><newline>
</descrip>

<item><tt/LocalInterface=IP_OR_FQDN/<newline>
Default: <tt>N/A</tt>
<p>
Particular local network interface that RADIUS client should
use in order to communicate with RADIUS servers. This parameter
can be useful on NAT machines to restrict number of network
interfaces used for RADIUS communication. By default this value
is empty and allows RADIUS requests to be sent on any (best suitable)
network interface. If you are not sure what you are doing, it is
better to leave this option unset.

<item><tt/RadiusPortRange=10000-11000/<newline>
Default: <tt>N/A</tt>
<p>
By default (if this option is not set) RADIUS client
allocates ports dynamically as specified by the operating system.
If you want to restrict RADIUS client to use ports from
a particular range only - set this parameter.

<item><tt/DefaultAuthPort=PORT_NO/<newline>
Default: <tt>1812</tt>
<p>
Default port number to be used for RADIUS authentication requests
(Access-Request packets), if not overriden by <tt/Servers/ attribute.

<item><tt/SharedSecret=SECRET/<newline>
Default: <tt>N/A (empty string)</tt>
<p>
Secret used to authenticate this GnuGk (NAS client) to RADIUS
server. It should be a cryptographically strong password. This is the default
value used, if no server-specific secret is set in the <tt/Servers/.

<item><tt/RequestTimeout=TIMEOUT_MS/<newline>
Default: <tt/2000/ (miliseconds)
<p>
Timeout (miliseconds) for RADIUS server response to a request
sent by GnuGk. If no response is received within this time period,
next RADIUS server is queried.

<item><tt/IdCacheTimeout=TIMEOUT_MS/<newline>
Default: <tt/9000/ (miliseconds)
<p>
Timeout (miliseconds) for RADIUS request 8-bit identifiers to be
unique. If all 8-bit identifier range is exhausted within this period,
new client socket (UDP socket) is allocation by RADIUS module. Let's
take the example: we have approximatelly 60 RRQs/sec - after ca. 4 seconds
8-bit identifiers range gets exhausted - new socket allocated - after next
4 seconds the second 8-bit identifiers range gets exhauted - third socket
allocated - after 9th second identifiers from the pool 1 are available again
- ... . In general, too long timeout - too much resources consumed,
too short timeout - RADIUS server may take incoming packets as duplicated
and therefore drop it.

<item><tt/SocketDeleteTimeout=TIMEOUT_MS/<newline>
Default: <tt/60000/ (miliseconds) - 60 s
<p>
Timeout for unused RADIUS sockets to be closed. It is used
in conjunction with <tt/IdCacheTimeout/ - additional sockets
created during heavy GK load time periods for serving incoming
requests are closed during idle periods.

<item><tt/RequestRetransmissions=NUMBER/<newline>
Default: <tt/2/
<p>
How many times a single RADIUS request is transmissed to every
configured RADIUS server (if no response is received). 1 means
no retransmission, 2 - single retransmission, ... . Exact retransmission
method is defined by <tt/RoundRobinServers/ attribute.

<item><tt/RoundRobinServers=BOOLEAN/<newline>
Default: <tt/1/
<p>
RADIUS requests retransmission method.
<p>
If set to 1, RADIUS request
is transmitted in the following way (until response is received):
<tscreen><verb>
Server #1 Attempt #1, Server #2 Attempt #1, ..., Server #N Attempt #1
...
Server #1 Attempt #RequestRetransmissions, ..., Server #1 Attempt #RequestRetransmissions
</verb></tscreen>
<p>
If set to 0, the following sequence is preserved:
<tscreen><verb>
Server #1 Attempt #1, ..., Server #1 Attempt #RequestRetransmissions
...
Server #N Attempt #1, ..., Server #N Attempt #RequestRetransmissions
</verb></tscreen>

<item><tt/AppendCiscoAttributes=BOOLEAN/<newline>
Default: <tt/0/
<p>
If set, Cisco Vendor Specific RADIUS attibutes are included
in RADIUS requests (h323-conf-id,h323-call-origin,h323-call-type).

<item><tt/IncludeTerminalAliases=BOOLEAN/<newline>
Default: <tt/1/
<p>
If set, Cisco VSA 'h323-ivr-out' attribute is sent with a list of aliases
the endpoint is registering (RRQ.m_terminalAlias). This attribute is provided
in order to provide fine control over the list of aliases the endpoint
is allowed to register with. Format of this attribute is:
<tscreen><verb>
	Cisco-AV-Pair = "h323-ivr-out=terminal-alias:" alias [,alias] [;]
Example:
	Cisco-AV-Pair = "h323-ivr-out=terminal-alias:helpdesk,support,77771;"
</verb></tscreen>

<item><tt/UseDialedNumber=BOOLEAN/<newline>
Default: <tt/0/
<p>
Select Called-Station-Id number type between the original one (as dialed
by the user) - <tt/UseDialedNumber=1/ - and the rewritten one - <tt/UseDialedNumber=0/.

</itemize>

<sect2>Section &lsqb;RadAliasAuth&rsqb;
<label id="radaliasauth">
<p>
This section defines configuration settings that enable
RADIUS authentication based on endpoint aliases and/or IP adresses
present in RRQ RAS requests, ARQ RAS request or Q.931 Setup request.
This authentication scheme is useful both for endpoints registered
at the gatekeeper (ARQ,RRQ) and calls from unregistered endpoints (Setup).

<itemize>
<item><tt/Servers=SERVER1[:AUTH_PORT[:ACCT_PORT[:SECRET]]];SERVER2[:AUTH_PORT[:ACCT_PORT[:SECRET]]];.../<newline>
Default: <tt>N/A</tt>
<p>
RADIUS servers to be used for RAS requests authentication.
This list can contain an arbitrary number of servers. The order of servers 
is important, because servers will be queried by the RADIUS module 
in the given order. If no port information is specified, port number from 
<tt/DefaultAuthPort/ will be used. If no secret is set, 
the default shared secret from <tt/SharedSecret/ is used.
Servers can be IP addresses or DNS names.

<descrip>
<tag/Example:/
<tt/Servers=192.168.3.1:1645;192.168.3.2:1812:1813:mysecret;radius.mycompany.com/
</descrip>

<item><tt/LocalInterface=IP_OR_FQDN/<newline>
Default: <tt>N/A</tt>
<p>
Particular local network interface that RADIUS client should
use in order to communicate with RADIUS servers. This parameter
can be useful on NAT machines to restrict number of network
interfaces used for RADIUS communication. By default this value
is empty and allows RADIUS requests to be sent on any (best suitable)
network interface. If you are not sure what you are doing, it is
better to leave this option unset.

<item><tt/RadiusPortRange=10000-11000/<newline>
Default: <tt>N/A</tt>
<p>
By default (if this option is not set) RADIUS client
allocates ports dynamically as specified by the operating system.
If you want to restrict RADIUS client to use ports from
a particular range only - set this parameter.

<item><tt/DefaultAuthPort=PORT_NO/<newline>
Default: <tt>1812</tt>
<p>
Default port number to be used for RADIUS authentication requests
(Access-Request packets), if not overriden by <tt/Servers/ attribute.

<item><tt/SharedSecret=SECRET/<newline>
Default: <tt>N/A (empty string)</tt>
<p>
Secret used to authenticate this GNU GK (NAS client) to RADIUS
server. It should be a cryptographically strong password. This is the default
value used, if no server-specific secret is set in the <tt/Servers/.

<item><tt/RequestTimeout=TIMEOUT_MS/<newline>
Default: <tt/2000/ (miliseconds)
<p>
Timeout (miliseconds) for RADIUS server response to a request
sent by GNU GK. If no response is received within this time period,
next RADIUS server is queried.

<item><tt/IdCacheTimeout=TIMEOUT_MS/<newline>
Default: <tt/9000/ (miliseconds)
<p>
Timeout (miliseconds) for RADIUS request 8-bit identifiers to be
unique. If all 8-bit identifier range is exhausted within this period,
new client socket (UDP socket) is allocation by RADIUS module. Let's
take the example: we have approximatelly 60 RRQs/sec - after ca. 4 seconds
8-bit identifiers range gets exhausted - new socket allocated - after next
4 seconds the second 8-bit identifiers range gets exhauted - third socket
allocated - after 9th second identifiers from the pool 1 are available again
- ... . In general, too long timeout - too much resources consumed,
too short timeout - RADIUS server may take incoming packets as duplicated
and therefore drop it.

<item><tt/SocketDeleteTimeout=TIMEOUT_MS/<newline>
Default: <tt/60000/ (miliseconds) - 60 s
<p>
Timeout for unused RADIUS sockets to be closed. It is used
in conjunction with <tt/IdCacheTimeout/ - additional sockets
created during heavy GK load time periods for serving incoming
requests are closed during idle periods.

<item><tt/RequestRetransmissions=NUMBER/<newline>
Default: <tt/2/
<p>
How many times a single RADIUS request is transmissed to every
configured RADIUS server (if no response is received). 1 means
no retransmission, 2 - single retransmission, ... . Exact retransmission
method is defined by <tt/RoundRobinServers/ attribute.

<item><tt/RoundRobinServers=BOOLEAN/<newline>
Default: <tt/1/
<p>
RADIUS requests retransmission method.
<p>
If set to 1, RADIUS request
is transmitted in the following way (until response is received):
<tscreen><verb>
Server #1 Attempt #1, Server #2 Attempt #1, ..., Server #N Attempt #1
...
Server #1 Attempt #RequestRetransmissions, ..., Server #1 Attempt #RequestRetransmissions
</verb></tscreen>
<p>
If set to 0, the following sequence is preserved:
<tscreen><verb>
Server #1 Attempt #1, ..., Server #1 Attempt #RequestRetransmissions
...
Server #N Attempt #1, ..., Server #N Attempt #RequestRetransmissions
</verb></tscreen>

<item><tt/AppendCiscoAttributes=BOOLEAN/<newline>
Default: <tt/1/
<p>
If set, Cisco Vendor Specific RADIUS attibutes are included
in RADIUS requests (h323-conf-id,h323-call-origin,h323-call-type).

<item><tt/IncludeTerminalAliases=BOOLEAN/<newline>
Default: <tt/1/
<p>
If set, Cisco VSA 'h323-ivr-out' attribute is sent with a list of aliases
the endpoint is registering (RRQ.m_terminalAlias). This attribute is provided
in order to provide fine control over the list of aliases the endpoint
is allowed to register with. Format of this attribute is:
<tscreen><verb>
	Cisco-AV-Pair = "h323-ivr-out=terminal-alias:" alias [,alias] [;]
Example:
	Cisco-AV-Pair = "h323-ivr-out=terminal-alias:helpdesk,support,77771;"
</verb></tscreen>

<item><tt/FixedUsername/<newline>
Default: <tt>N/A</tt>
<p>
If this parameter is set, it overwrites a value of User-Name RADIUS attribute
for outgoing RADIUS request. That means every Access-Request will be
authenticated as for user <tt/FixedUsername/.

<item><tt/FixedPassword/<newline>
Default: <tt>N/A</tt>
<p>
If not set, User-Password is a copy of User-Name. For example, if User-Name
is 'john' then User-Password will also be set to 'john'. Setting this
parameter overrides this behavious and User-Password attribute will be
always set to the value of <tt/FixedPassword/.

<descrip>
<tag/Example 1:/
<tscreen><verb>
(Neither FixedUsername nor FixedPassword set)
</verb></tscreen>
All endpoints will be authenticated using their alias as the username
and the password. That means, for example, endpoint 'EP1' will be authenticated
with the username 'EP1 and the password 'EP1'.
</descrip>

<descrip>
<tag/Example 2:/
<tscreen><verb>
(FixedUsername not set)
FixedPassword=ppp
</verb></tscreen>
All endpoints will be authenticated using their alias and the password 'ppp'.
</descrip>

<descrip>
<tag/Example 3:/
<tscreen><verb>
FixedUsername=ppp
FixedPassword=ppp
</verb></tscreen>
All endpoints will be authenticated using the username 'ppp'
and the password 'ppp'.
</descrip>

<item><tt/UseDialedNumber=BOOLEAN/<newline>
Default: <tt/0/
<p>
Select Called-Station-Id number type between the original one (as dialed
by the user) - <tt/UseDialedNumber=1/ - and the rewritten one - <tt/UseDialedNumber=0/.

</itemize>

<sect2>Section &lsqb;GkLDAP::LDAPAttributeNames&rsqb;
<p>
This section defines which LDAP attribute names to use.

<itemize>
<item><tt/H323ID/<newline>
<p>
The endpoint's H.323 alias. Needs to be unique within the used LDAP tree
(this i why we use the mail address by default).

<item><tt/TelephonNo/<newline>
<p>
The endpoint's E.164 alias.

<item><tt/voIPIpAddress/<newline>
<p>
The IP address to be compared against when using <tt/LDAPAliasAuth/
For now, only a single value is allowed here.

<item><tt/H235PassWord/<newline>
<p>
The plain text password to be compared against when using H.235
(<tt/LDAPPasswordAuth/ in Gatekeeper::Auth).
For now, only a single value is allowed here.
</itemize>

<sect2>Section &lsqb;GkLDAP::Settings&rsqb;
<p>
This section defines the LDAP server and standard LDAP client operating
parameters to be used.

<itemize>
<item><tt/ServerName/<newline>
Default: <tt/ldap/
<p>
The LDAP server's DNS name.

<item><tt/ServerPort/<newline>
Default: <tt/389/
<p>
The LDAP server's TCP port (usually 389).

<item><tt/SearchBaseDN/<newline>
Default: <tt/o=University of Michigan, c=US/
<p>
Entry point into the server's LDAP tree structure.
Searches are only made below this root node.

<item><tt/BindUserDN/<newline>
Default: <tt/cn=Babs Jensen,o=University of Michigan, c=US/
<p>
The distinguished name the gatekeeper uses to bind
to the LDAP server. Leave empty if you want to access
the LDAP server anonymously.

<item><tt/BindUserPW/<newline>
Default: <tt/ReallySecretPassword/
<p>
If you specified <tt/BindUserDN/, then specify the corresponding
password to be used for binding here.

<item><tt/sizelimit/<newline>
Default: <tt/0/
<p>
Maximum number of results the server may return in response
to a single search query. The gatekeeper expects each LDAP
to only yields one or zero results anyway, so this parameter
is rather useless.

<item><tt/timelimit/<newline>
Default: <tt/0/
<p>
Maximum number of seconds a query may take until it's considered as "failed".

</itemize>

<sect2>Section &lsqb;Gatekeeper::Acct&rsqb;
<label id="gkacct">
<p>
The section defines a list of modules that will be performing accounting.
The accounting is for logging gatekeeper on/off events and call start/stop/update
events. Each accounting module logs received events to a module specific storage.
Such storage can be a plain text file or a RADIUS server and many
more. The configuration is very similar to the one for gatekeeper authentication
(see <ref id="gkauth" name="[Gatekeeper::Auth]">).


All CDRs are also sent to the status port and can be used by external applications.

<descrip>
<tag/Syntax:/
<tscreen><verb>
acctmod=actions

 <acctmod> := FileAcct | RadAcct | SQLAcct | ...
 <actions> := <control>[;<event>,<event>,...]
 <control> := optional | required | sufficient | alternative
 <event>   := start | stop | update | on | off
</verb></tscreen>
</descrip>
The event list tells the gatekeeper, which events should trigger logging
with the given accounting module (if an event type is supported by the module):
<itemize>
<item><tt/start/ - a call has been started (that does not mean it has been
	connected - either Setup message has been received or ACF has been sent
	in direct GK mode),
<item><tt/update/ - a call is active and the periodic update is performed
	to reflect the new call duration. Frequency of such updates is determined
	by <bf/AcctUpdateInterval/ variable from <ref id="calltable" name="[CallTable]">
	section,
<item><tt/stop/ - a call has been disconnected (removed from the GK call table),
<item><tt/on/ - the gatekeeper has been started,
<item><tt/off/ - the gatekeeper has been shut down.
</itemize>
An event logging by a module may results in one of the three result codes:
<bf/ok/, <bf/fail/, <bf/next/.
<itemize>
<item><tt/ok/ - the event has been logged successfully by this module,
<item><tt/fail/ - the module failed to log the event,
<item><tt/next/ - the event has not been logged by this module, because the module
  is not configured for/does not support this event type.
</itemize>
Accounting modules can be stacked to log events by multiple modules or to create
failover setups. <bf/control/ flag for each module, along with result codes,
define what is the final status of the event processing by the whole module stack.
If the final result is <bf/failure/, some special actions may take place. Currently,
if a call <bf/start/ event logging fails, the call is disconnected immediatelly.
The following <bf/control/ flags are recognized:
<itemize>
<item><tt/required/ - if the module fails to log an event, the final status
                      is set to failure and the event is passed down to any remaining
					  modules,
<item><tt/optional/ - the module tries to log an event, but the final status
                      is not affected by success or failure (except when the module
					  is last on the list). The event is always passed down
					  to any remaining modules,
<item><tt/sufficient/ - the module determines the final status. If an event
                        is logged successfully, no remaining modules are processed.
						Otherwise the final status is set to failure and the event
						is passed down to any remaining modules,
<item><tt/alternative/ - if the module logs an event successfully, no remaining
                         modules are processed. Otherwise the final status is
						 not modified and the event is passed down to any remaining
						 modules.
</itemize>

Currently supported accounting modules:
<itemize>
<item><tt>FileAcct</tt>
<p>
A plain CDR text file logger. It outputs status line like CDR lines to
a specified text file. This module supports only <bf/stop/ accounting event.
Configuration settings are read from <ref id="fileacct" name="[FileAcct]"> section.

<item><tt>RadAcct</tt>
<p>
This module performs RADIUS accounting. It supports all event types
(start, stop, update, on, off).
See the section <ref id="radacct" name="[RadAcct]"> for configuration details.

<item><tt>SQLAcct</tt>
<p>
This module performs direct SQL accounting. It supports (start, stop, update)
event types. 
See the section <ref id="sqlacct" name="[SQLAcct]"> for configuration details.

<item><tt>default</tt>
<p>
This is a special pseudo module - it is used to set the final status
if preceeding modules have not determined it. The format is as follows:
<descrip>
<tag/Syntax:/
<tscreen><verb>
 default=<status>[;<event>,<event>,...]
 <status> := accept | fail
 <event>  := start | stop | update | on | off
</verb></tscreen>
</descrip>

</itemize>

The sample configuration #1 (try to log call start/stop with RADIUS server,
and always write a CDR to a text file):
<descrip>
<tag/Example:/
<tt/RadAcct=optional;start,stop/<newline>
<tt/FileAcct=required/<newline>
</descrip>

The sample configuration #2 (try to log call start/stop with RADIUS server,
if it fails use a CDR log file):
<descrip>
<tag/Example:/
<tt/RadAcct=alternative;start,stop/<newline>
<tt/FileAcct=sufficient;stop/<newline>
<tt/default=accept/<newline>
</descrip>
The <bf/default/ rule is required here to prevent calls from being rejected
because of RadAcct start event logging failure. If RadAcct returns <bf/fail/
return code, it is passed down to FileAcct module. FileAcct module does not
support <bf/start/ events, so it returns <bf/next/ return code. If there were
no the <bf/default/ rule, the final status would be failure, because no module
has been able to log the event.

The sample configuration #3 (always log call start and stop events with RADIUS
server, if it fails for call stop event, use a CDR file to store call info):
<descrip>
<tag/Example:/
<tt/RadAcct=alternative;start,stop/<newline>
<tt/FileAcct=sufficient;stop/<newline>
<tt/default=fail;start/<newline>
</descrip>
The <bf/default/ rule is optional here. If RadAcct returns <bf/fail/
return code for <bf/start/ event, the code is passed down to FileAcct module.
FileAcct module does not support <bf/start/ events, so it returns <bf/next/
return code. The <bf/default/ rule ensures, that the call is disconnected
if call start event could not has been logged with RadAcct. But we want
to store a CDR in a text file in case the RADIUS server is down when the call
disconnects, so we can fetch call duration into a billing system later.

<sect2>Section &lsqb;FileAcct&rsqb;
<label id="fileacct">
<p>
This accounting module writes CDR lines to a specified text file. The CDR
format can be a standard one (the same as displayed by the status interface)
or a customized one (using parametrized query string).

<itemize>
<item>
<tt/DetailFile=FULL_PATH_AND_FILENAME/<newline>
Default: N/A
<p>
A full path to the CDR plain text file. If a file with the given name already 
exists, new CDRs will be appended at the end of the file.

<item>
<tt/StandardCDRFormat=0/<newline>
Default: <tt/1/
<p>
Use a CDR format compatible with the status interface CDR format (<tt/1/)
or build a custom CDR strings from the <bf/CDRString/ parametrized string.

<item>
<tt/CDRString=%s|%g|%u|%{Calling-Station-Id}|%{Called-Station-Id}|%d|%c/<newline>
Default: N/A
<p>
If <bf/StandardCDRFormat/ is disabled (0) or not specified at all, 
this paramterized string instructs the gatekeeper how to build a custom
CDRs. Parameters are specified using <tt/%/ character and can be one letter
(like <tt/%n/) or longer (like <tt/%{CallId}/). Any remaining characters that
are not parameter names are simply copied to a final CDR string. The following
parameters are recognized:
<itemize>
<item><tt/%g/ - gatekeeper name
<item><tt/%n/ - call number (not unique after gatekeeper restart)
<item><tt/%d/ - call duration (seconds)
<item><tt/%c/ - Q.931 disconnect cause (decimal integer)
<item><tt/%s/ - unique (for this gatekeeper) session identifier (Acct-Session-Id)
<item><tt/%u/ - H.323 ID of the calling party
<item><tt/%{CallId}/ - H.323 call identifier (16 hex 8-bit digits)
<item><tt/%{ConfId}/ - H.323 conference identifier (16 hex 8-bit digits)
<item><tt/%{setup-time}/ - timestamp string for Q.931 Setup message
<item><tt/%{connect-time}/ - timestamp string for a call connected event
<item><tt/%{disconnect-time}/ - timestamp string for a call disconnect event
<item><tt/%{caller-ip}/ - signaling IP addres of the caller
<item><tt/%{caller-port}/ - signaling port of the caller
<item><tt/%{callee-ip}/ - signaling IP addres of the called party
<item><tt/%{callee-port}/ - signaling port of the called party
<item><tt/%{src-info}/ - a colon separated list of source aliases
<item><tt/%{dest-info}/ - a colon separated list of destination aliases
<item><tt/%{Calling-Station-Id}/ - calling party number
<item><tt/%{Called-Station-Id}/ - called party number (rewritten)
<item><tt/%{Dialed-Number}/ - dialed number (as received from the calling party)
</itemize><newline>

<item><tt/TimestampFormat=Cisco/<newline>
Default: <tt>N/A</tt>
<p>
Format of timestamp strings printed in CDR strings. If this setting
is not specified, a global one from the main gatekeeper section is applied.

<item>
<tt/Rotate=hourly | daily | weekly | monthly | L... | S.../<newline>
Default: N/A
<p>
If set, the CDR file will be rotated based on this setting. Hourly rotation
enables rotation once per hour, daily - once per day, weekly - once per week
and monthly - once per month. An exact rotation moment is determined by a combination
of RotateDay and RotateTime. During rotation, an existing file is renamed 
to CURRENT_FILENAME.YYYYMMDD-HHMMSS, where YYYYMMDD-HHMMSS is replaced with 
the current timestamp, and new CDRs are logged to an empty file.<newline>
In addition, rotation per number of CDRs written (L...) and per file size (S...)
is supported. The <tt/L/ prefix specifies a number of CDR lines written,
the <tt/S/ prefix specifies CDR file size. <tt/k/ and <tt/m/ suffixes can
be used to speficy throusands (kilobytes) and millions (megabytes). 
See the examples for more details.

<descrip>
<tag/Example 1 - no rotation:/
<tt/&lsqb;FileAcct&rsqb;/<newline>
<tt>DetailFile=/var/log/gk/cdr.log</tt><newline>
</descrip>

<descrip>
<tag/Example 2 - rotate every hour (00:45, 01:45, ..., 23:45):/
<tt/&lsqb;FileAcct&rsqb;/<newline>
<tt>DetailFile=/var/log/gk/cdr.log</tt><newline>
<tt>Rotate=hourly</tt><newline>
<tt>RotateTime=45</tt><newline>
</descrip>

<descrip>
<tag/Example 3 - rotate every day at 23:00 (11PM):/
<tt/&lsqb;FileAcct&rsqb;/<newline>
<tt>DetailFile=/var/log/gk/cdr.log</tt><newline>
<tt>Rotate=daily</tt><newline>
<tt>RotateTime=23:00</tt><newline>
</descrip>

<descrip>
<tag/Example 4 - rotate every Sunday at 00:59:/
<tt/&lsqb;FileAcct&rsqb;/<newline>
<tt>DetailFile=/var/log/gk/cdr.log</tt><newline>
<tt>Rotate=weekly</tt><newline>
<tt>RotateDay=Sun</tt><newline>
<tt>RotateTime=00:59</tt><newline>
</descrip>

<descrip>
<tag/Example 5 - rotate on the last day of each month:/
<tt/&lsqb;FileAcct&rsqb;/<newline>
<tt>DetailFile=/var/log/gk/cdr.log</tt><newline>
<tt>Rotate=monthly</tt><newline>
<tt>RotateDay=31</tt><newline>
<tt>RotateTime=23:00</tt><newline>
</descrip>

<descrip>
<tag/Example 6 - rotate per every 10000 CDRs:/
<tt/&lsqb;FileAcct&rsqb;/<newline>
<tt>DetailFile=/var/log/gk/cdr.log</tt><newline>
<tt>Rotate=L10000</tt><newline>
</descrip>

<descrip>
<tag/Example 7 - rotate per every 10 kilobytes:/
<tt/&lsqb;FileAcct&rsqb;/<newline>
<tt>DetailFile=/var/log/gk/cdr.log</tt><newline>
<tt>Rotate=S10k</tt><newline>
</descrip>

</itemize>

<sect2>Section &lsqb;RadAcct&rsqb;
<label id="radacct">
<p>
This accounting module sends accounting data to a RADIUS server. Module
configuration is almost the same as for RADIUS authenticators (see
<ref id="radauth" name="[RadAuth]"> and <ref id="radaliasauth" name="[RadAliasAuth]">
for more details on the parameters).

<itemize>
<item><tt/Servers=SERVER1[:AUTH_PORT:ACCT_PORT[:SECRET]];SERVER2[:AUTH_PORT:ACCT_PORT[:SECRET]];.../<newline>
Default: <tt>N/A</tt>
<p>
RADIUS servers to send accounting data to. If no port information is given,
port number from <tt/DefaultAcctPort/ is be used. If no secret is set, 
the default shared secret from <tt/SharedSecret/ is used. Server names could 
be either IP addresses or DNS names.

<descrip>
<tag>Sample <tt/Servers/ lines:</tag>
<tt>Servers=192.168.1.1</tt><newline>
<tt>Servers=192.168.1.1:1645:1646</tt><newline>
<tt>Servers=192.168.1.1:1645:1646:secret1</tt><newline>
<tt>Servers=radius1.mycompany.com:1812:1813</tt><newline>
<tt>Servers=radius1.mycompany.com;radius2.mycompany.com</tt><newline>
<tt>Servers=radius1.mycompany.com:1812:1813:secret1;radius2.mycompany.com:1812:1813:secret2</tt><newline>
</descrip>

<item><tt/LocalInterface=IP_OR_FQDN/<newline>
Default: <tt>N/A</tt>
<p>
Particular local network interface that RADIUS client should
use in order to communicate with RADIUS servers.

<item><tt/RadiusPortRange=10000-11000/<newline>
Default: <tt>N/A</tt>
<p>
By default (if this option is not set) RADIUS client
allocates ports dynamically as specified by the operating system.
If you want to restrict RADIUS client to use ports from
a particular range only - set this parameter.

<item><tt/DefaultAcctPort=PORT_NO/<newline>
Default: <tt>1813</tt>
<p>
Default port number to be used for RADIUS accounting requests,
if not overriden by <tt/Servers/ attribute.

<item><tt/SharedSecret=SECRET/<newline>
Default: <tt>N/A (empty string)</tt>
<p>
A secret used to authenticate this GnuGk (NAS client) to RADIUS
server. It should be a cryptographically strong password. This is the default
value used, if no server-specific secret is set in the <tt/Servers/.

<item><tt/RequestTimeout=TIMEOUT_MS/<newline>
Default: <tt/2000/ (miliseconds)
<p>
Timeout (miliseconds) for RADIUS server response to a request
sent by GnuGk. If no response is received within this time period,
next RADIUS server is queried.

<item><tt/IdCacheTimeout=TIMEOUT_MS/<newline>
Default: <tt/9000/ (miliseconds)
<p>
Timeout (miliseconds) for RADIUS request 8-bit identifiers to be
unique.

<item><tt/SocketDeleteTimeout=TIMEOUT_MS/<newline>
Default: <tt/60000/ (miliseconds) - 60 s
<p>
Timeout for unused RADIUS sockets to be closed.

<item><tt/RequestRetransmissions=NUMBER/<newline>
Default: <tt/2/
<p>
How many times a single RADIUS request is transmissed to every
configured RADIUS server (if no response is received).

<item><tt/RoundRobinServers=BOOLEAN/<newline>
Default: <tt/1/
<p>
RADIUS requests retransmission method.

<item><tt/AppendCiscoAttributes=BOOLEAN/<newline>
Default: <tt/0/
<p>
If set, Cisco Vendor Specific RADIUS attibutes are included
in RADIUS requests (h323-conf-id,h323-call-origin,h323-call-type).

<item><tt/TimestampFormat=ISO8601/<newline>
Default: <tt>N/A</tt>
<p>
Format of timestamp strings sent in RADIUS attributes. If this setting
is not specified, a global one from the main gatekeeper section is applied.

<item><tt/UseDialedNumber=BOOLEAN/<newline>
Default: <tt/0/
<p>
Select Called-Station-Id number type between the original one (as dialed
by the user) - <tt/UseDialedNumber=1/ - and the rewritten one - <tt/UseDialedNumber=0/.

</itemize>

<sect2>Section &lsqb;SQLAcct&rsqb;
<label id="sqlacct">
<p>
This accounting module stores accounting information directly
to an SQL database. Many configuration settings are common with
other SQL modules.

<itemize>
<item><tt/Driver=MySQL | PostgreSQL/<newline>
Default: N/A
<p>
SQL database driver to use. Currently, <tt/MySQL/ and <tt/PostgreSQL/ drivers
are implemented.

<item><tt/Host=DNS[:PORT] | IP[:PORT][;DNS[:PORT] | IP[:PORT]].../<newline>
Default: <tt/localhost/
<p>
SQL server host address. Can be in the form of <tt/DNS[:PORT]/ or <tt/IP[:PORT]/.
Like <tt/sql.mycompany.com/ or <tt/sql.mycompany.com:3306/ or <tt/192.168.3.100/.
Multiple hosts, separated by the semicolon, may be specified to support failover.

<item><tt/Database=billing/<newline>
Default: <tt/billing/
<p>
The database name to connect to.

<item><tt/Username=gnugk/<newline>
<p>
The username used to connect to the database.

<item><tt/Password=secret/<newline>
<p>
The password used to connect to the database.
If the password is not specified, a database connection attempt 
without any password will be made.
If <tt/EncryptAllPasswords/ is enabled, or a <tt/KeyFilled/ variable is defined
in this section, the password is in an encrypted form and should be created 
using the <tt/addpasswd/ utility.

<item><tt/StartQuery=INSERT .../<newline>
Default: <tt>N/A</tt>
<p>
Defines SQL query used to insert a new call record to the database. The query
is parametrized - that means parameter replacement is made before each query
is executed. Parameter placeholders are denoted by % character and can be one
letter (like %u) or whole strings (like %{src-info}). Specify %% to embed 
a percent character inside the query string (like <bf/%%/).
For <tt/SQLAcct/ the following parameters are defined:
<itemize>
<item><tt/%g/ - gatekeeper name
<item><tt/%n/ - call number (not unique after gatekeeper restart)
<item><tt/%d/ - call duration (seconds)
<item><tt/%c/ - Q.931 disconnect cause (<bf/hexadecimal/ integer)
<item><tt/%s/ - unique (for this gatekeeper) call (Acct-Session-Id)
<item><tt/%u/ - H.323 ID of the calling party
<item><tt/%{gkip}/ - IP address of the gatekeeper
<item><tt/%{CallId}/ - H.323 call identifier (16 hex 8-bit digits)
<item><tt/%{ConfId}/ - H.323 conference identifier (16 hex 8-bit digits)
<item><tt/%{setup-time}/ - timestamp string for Q.931 Setup message
<item><tt/%{connect-time}/ - timestamp string for a call connected event
<item><tt/%{disconnect-time}/ - timestamp string for a call disconnect event
<item><tt/%{caller-ip}/ - signaling IP addres of the caller
<item><tt/%{caller-port}/ - signaling port of the caller
<item><tt/%{callee-ip}/ - signaling IP addres of the called party
<item><tt/%{callee-port}/ - signaling port of the called party
<item><tt/%{src-info}/ - a colon separated list of source aliases
<item><tt/%{dest-info}/ - a colon separated list of destination aliases
<item><tt/%{Calling-Station-Id}/ - calling party number
<item><tt/%{Called-Station-Id}/ - called party number (rewritten Dialed-Number)
<item><tt/%{Dialed-Number}/ - dialed number (as received from the calling party)
</itemize>
<p>
Sample query string:
<tscreen><verb>
INSERT INTO call (gkname, sessid, username, calling, called) 
	VALUES ('%g', '%s', '%u', '%{Calling-Station-Id}', '%{Called-Station-Id}')
</verb></tscreen>

<item><tt/StartQueryAlt=INSERT .../<newline>
Default: <tt>N/A</tt>
<p>
Defines SQL query used to insert a new call record to the database in case
the <tt/StartQuery/ failed for some reason (the call already exists, for example).
The syntax and parameters are the same as for <tt/StartQuery/.

<item><tt/UpdateQuery=UPDATE .../<newline>
Default: <tt>N/A</tt>
<p>
Defines SQL query used to update call record in the database with the current 
call state. The syntax and parameters are the same as for <tt/StartQuery/.
<p>
Sample query string:
<tscreen><verb>
UPDATE call SET duration = %d WHERE gkname = '%g' AND sessid = '%s'
</verb></tscreen>

<item><tt/StopQuery=UPDATE .../<newline>
Default: <tt>N/A</tt>
<p>
Defines SQL query used to update call record in the database when the call
is finished (disconnected). The syntax and parameters are the same 
as for <tt/StartQuery/.
<p>
Sample query string:
<tscreen><verb>
UPDATE call SET duration = %d, dtime = '%{disconnect-time}' WHERE gkname = '%g' AND sessid = '%s'
</verb></tscreen>

<item><tt/StopQueryAlt=INSERT .../<newline>
Default: <tt>N/A</tt>
<p>
Defines SQL query used to update call record in the database when the call
is finished (disconnected) in case the regular <tt/StopQuery/ failed (because
the call record does not yet exist, for example). The syntax and parameters 
are the same as for <tt/StartQuery/.
<p>
Sample query string:
<tscreen><verb>
INSERT INTO call (gkname, sessid, username, calling, called, duration) 
	VALUES ('%g', '%s', '%u', '%{Calling-Station-Id}', '%{Called-Station-Id}', %d)
</verb></tscreen>

<item><tt/TimestampFormat=MySQL/<newline>
Default: <tt>N/A</tt>
<p>
Format of timestamp strings used in queries. If this setting
is not specified, a global one from the main gatekeeper section is applied.

</itemize>

<sect2>Section &lsqb;NATedEndpoints&rsqb;
<p>
The gatekeeper can automatically detect whether an endpoint is behind NAT.
However, if the detection fails, you can specify it manually in this section.

<descrip>
<tag/Format:/
<tt/alias=true,yes,1,.../
<tag/Example:/
Specify an endpoint with alias 601 is behind NAT.
<quote/<tt/601=true//
</descrip>

<sect2>Section &lsqb;CTI::Agents&rsqb;
<p>
This section allows the configuration of a so called virtual queues to
allow inbound call distribution by an external application via the
status port.
A virtual queue has an H.323 alias that can be called like an endpoint.

Upon arrival of an ARQ on a virtual queue, the gatekeeper signals
a RouteRequest on the status port and waits for an external application
to respond with either a RouteReject (then the ARQ will be rejected)
or with RouteToAlias/RouteToGateway which leads to the ARQ being rewritten so the call
will be routed to the alias (eg. call center agent) specified by
the external application.

If no answer is received after a timeout period, the call is terminated.

You can specify virtual queues in three ways:
<itemize>
<item><tt/exact alias name/ - a list of aliases is given. If an ARQ destination
  alias matches one these names, the virtual queue is activated,
<item><tt/prefix/ - a list of prefixes is given. If an ARQ destination alias
  starts with one these prefixes, the virtual queue is activated,
<item><tt/regular expression/ - a regular expression is given. If an ARQ destination
  alias matches the expression, the virtual queue is activated.
</itemize>

See the monitoring section for details on the messages and responses.

<itemize>
<item>
<tt/VirtualQueueAliases/<newline>
Default: none
<p>
This defines a list of H.323 aliases for the virtual queues (used with the vqueue RoutingPolicy).

<descrip>
<tag/Example:/
<quote/<tt/VirtualQueueAliases=sales,support//
<newline>
</descrip>

<item>
<tt/VirtualQueuePrefixes/<newline>
Default: none
<p>
This defines a list of prefixes for the virtual queues (used with the vqueue RoutingPolicy).

<descrip>
<tag/Example:/
<quote/<tt/VirtualQueuePrefixes=001215,1215//
<newline>
</descrip>

<item>
<tt/VirtualQueueRegex/<newline>
Default: none
<p>
This defines a regular expression for the virtual queues (used with the vqueue RoutingPolicy).

<descrip>
<tag/Example (numbers starting with 001215 or 1215):/
<quote/<tt/VirtualQueueRegex=^(001|1)215[0-9]*$//
<newline>
</descrip>

<item>
<tt/RequestTimeout/<newline>
Default: <tt/10/
Timeout in seconds for the external application to answer the RouteRequest.
If no answer is received during this time an ARJ will be sent to
the caller.
</itemize>

<sect1>Per-Endpoint Configuration Settings
<label id="epconfig">
<p>
In addition to the standard configuration file options, per-endpoint configuration
settings can be specified in the config file. The syntax is as follows:

<tscreen><verb>
[EP::ALIAS]
Key Name=Value String
</verb></tscreen>

<tt/ALIAS/ is replaced with an actual alias for an endpoint the settings
should apply to. Currently, the following options are recognized:

<itemize>
<item><tt/Capacity=10/<newline>
Default: <tt/-1/
<p>
Call capacity for an endpoint. No more than <tt/Capacity/ concurrent
calls will be sent to this endpoint. In case of gateways, if more than one
gateway matches a dialed number, a call will be sent to the first available
gateway (that has available capacity).

<item><tt/GatewayPriority=1/<newline>
Default: <tt/1/
<p>
Apply only to gateways. Allow priority based routing in case, when more
than one gateway matches a dialed number. The smaller value the higher priority
is assigned to a gateway. A call is routed to the first available gateway
(that has available capacity) with the highest priority (the smallest
<tt/GatewayPriority/ values).

<item><tt/GatewayPrefixes=0048,0049,0044/<newline>
Default: <tt>N/A</tt>
<p>
Additional prefixes for this gateway. Apply only to gateways.

</itemize>

Example:

<tscreen><verb>
[RasSrv::PermanentEndpoints]
192.168.1.1=gw1;48
192.168.1.2=gw2;48

[EP::gw1]
Capacity=60
GatewayPriority=1

[EP::gw2]
Capacity=30
GatewayPriority=2
</verb></tscreen>

In this example, calls will be sent to the gateway <tt/gw1/ until its
capacity is fully utilized (60 concurrent calls) and then to the gateway <tt/gw2/.

<!----------          Next Section          ---------->
<sect>Monitoring the Gatekeeper (Reference)
<label id="monitor">
<p>
<sect1>Status Port
<p>
The status port is the external interface for monitoring and controlling the gatekeeper.
The gatekeeper will send out messages about ongoing calls to all
connected clients and it can receive commands via this interface.

<p>
The messages sent by the gatekeeper to the status port are groupped 
into three <bf/output trace levels/:
<itemize>
<item>Level 0
	<quote>
	Reload notifications and direct replies to entered commands.
	</quote>
<item>Level 1
	<quote>
	Reload notifications, direct replies to entered commands, CDRs and Route Requests.
	</quote>
<item>Level 2
	<quote>
	Output everything (reload notifications, direct replies to entered commands, 
	CDRs, Route Requests, RAS, ...). This is the <bf/default/ output level.
	</quote>
</itemize>
The client connected to the status port can choose the output level it is interested in.

<p>
The interface is a simple TCP port (default: 7000), you can connect to with telnet or another client. One example of a different client is the Java GUI, aka GkGUI.
Another example is the Automatic Call Distribution application, aka GnuGk ACD.

<sect2>Application Areas
<p>
What you do with the powers of the Status Interface is up to you, but here are a few ideas:
<itemize>
<item>Call Monitoring
<item>Monitoring the registered endpoints
<item>Graphical User Interface
<quote>
See GkGUI.
</quote>
<item>Call Routing
<quote>
See GnuGk ACD.
</quote>
<item>Billing Applications
<quote>
Analyse the CDR messages and forward them to a billing application.
</quote>
<item>Interfacing external extensions
<quote>
If you don't want to publish the source code to additinal features, just publish the core functionality and interface to it through the status interface and keep the external part private.
</quote>
</itemize>
<p>
<sect2>Examples
<p>
Suppose you are just interested in the CDRs (call details records) and want to process them as a batch at regular intervals.

Here is a simple Perl script (<tt/gnugk_cdr.pl/) that starts the gatekeeper and also forks a very simple client for the Status Interface and writes just the CDRs into a logfile. You'll have to modify it a little to fit your needs.

<verb>
#!/usr/bin/perl
# sample program that demonstrates how to write the CDRs to a log file
use strict;
use IO::Socket;
use IO::Handle;

my $logfile = "/home/jan/cdr.log";	# CHANGE THIS
my $gk_host = "localhost";
my $gk_port = 7000;
my $gk_pid;

if ($gk_pid = fork()) {
	# parent will listen to gatekeeper status
	sleep(1);	# wait for gk to start
	my $sock = IO::Socket::INET->new(PeerAddr => $gk_host, PeerPort => $gk_port, Proto => 'tcp');
	if (!defined $sock) {
		die "Can't connect to gatekeeper at $gk_host:$gk_port";
	}
	$SIG{HUP} = sub { kill 1, $gk_pid; };	# pass HUP to gatekeeper
	$SIG{INT} = sub { close (CDRFILE); kill 2, $gk_pid; };	# close file when terminated

	open (CDRFILE, ">>$logfile");
	CDRFILE->autoflush(1);	# don't buffer output
	while (!$sock->eof()) {
		my $msg = $sock->getline();
		$msg = (split(/;/, $msg))[0];	# remove junk at end of line
		my $msgtype = (split(/\|/, $msg))[0];
		if ($msgtype eq "CDR") {
			print CDRFILE "$msg\n";
		}
	}
	close (CDRFILE);
} else {
	# child starts gatekeeper
	exec("gnugk");
}
</verb>
<p>
Keep in mind that this is just an example to show the usage of the status port.
You can use the FileAcct module to log CDRs in a production system.

<sect2>GUI for the Gatekeeper
<p>
There are several Graphical User Interface (GUI) frontends for the gatekeeper.

<itemize>
<item>Java GUI<p>
Developed by Jan Willamowius.
You can monitor the registrations and calls that go through the gatekeeper.
A right-click on a button gives you a popup menu for that endpoint.

This GUI works with Java 1.0 built into most web browsers.
For security reasons the GUI must be run as a standalone application
or served by a web server on the same IP number as the gatekeeper
(you cannot run it as an applet via a local file).

The program is available at
<url url="http://www.gnugk.org/h323gui.html">

<item>GkGUI<p>
A new standalone Java program developed by
<url url="http://www.citron.com.tw/" name="Citron Network Inc.">
It requires Java 1.4. New features include:

<itemize>
<item>Monitor multiple gatekeepers simultaneously.
<item>Two view modes: Button List and Tree List.
<item>Call Detail Record(CDR) and statistics.
<item>GK Status Log.
<item>Different colors for different endpoint types.
<item>Modify gatekeeper configuration.
<item>Forcedly unregister endpoints.
<item>Save and print status log and CDR.
</itemize>

The GkGUI is released under GNU General Public License, available at
<url url="http://www.gnugk.org/h323develop.html#java">
</itemize>

<sect1>Commands (Reference)
<p>
This section lists all commands that you can isue to the status port (manually or with an external application). All commands are case-insensitive. But some parameters may be case-sensitive.
<p>
The command <tt/help/ or <tt/h/ will show you a list of all available commands.
<p>
<itemize>
<item><tt/Reload/
<p>Reload the configuration.

<item><tt/Version/, <tt/v/
<p>Show the version and OS information of the gatekeeper.

<item><tt/Statistics/, <tt/s/
<p>Show the statistics information of the gatekeeper.
<descrip>
<tag/Example:/
<tscreen><verb>
Statistics
-- Endpoint Statistics --
Total Endpoints: 21  Terminals: 17  Gateways: 4  NATed: 2
Cached Endpoints: 1  Terminals: 1  Gateways: 0
-- Call Statistics --
Current Calls: 1 Active: 1 From Neighbor: 0 From Parent: 0
Total Calls: 1539  Successful: 1076  From Neighbor: 60  From Parent: 5
Startup: Fri, 21 Jun 2002 10:50:22 +0800   Running: 11 days 04:22:59
;
</verb></tscreen>
</descrip>

<item><tt/PrintAllRegistrations/, <tt/r/, <tt/?/
<p>Show all registered endpoints.
<descrip>
<tag/Format:/
<tscreen><verb>
AllRegistrations
RCF|IP:Port|Aliases|Terminal_Type|EndpointID
...
Number of Endpoints: n
;
</verb></tscreen>
<tag/Example:/
<tscreen><verb>
AllRegistrations
RCF|10.1.1.10:1720|800:dialedDigits=Wei:h323_ID|terminal|1289_endp
RCF|10.0.1.43:1720|613:dialedDigits=Jacky Tsai:h323_ID|terminal|1328_endp
RCF|10.0.1.55:1720|705:dialedDigits=Sherry Liu:h323_ID|terminal|1333_endp
Number of Endpoints: 3
;
</verb></tscreen>
</descrip>

<item><tt/PrintAllRegistrationsVerbose/, <tt/rv/, <tt/??/
<p>Show details of all registered endpoints.
<descrip>
<tag/Format:/
<tscreen><verb>
AllRegistrations
RCF|IP:Port|Aliases|Terminal_Type|EndpointID
Registration_Time C(Active_Call/Connected_Call/Total_Call) &lt;r&gt;
[Prefixes: ##] (gateway only)
...
Number of Endpoints: n
;
</verb></tscreen>
<tag/Example:/
<tscreen><verb>
AllRegistrations
RCF|10.0.1.8:1720|Accel-GW2:h323_ID|gateway|1322_endp
Wed, 26 Jun 2002 16:40:03 +0800 C(1/5/33) &lt;1&gt;
Prefixes: 09,002
RCF|10.1.1.10:1720|800:dialedDigits=Wei:h323_ID|terminal|1289_endp
Wed, 26 Jun 2002 16:40:55 +0800 C(0/32/39) &lt;1&gt;
RCF|10.0.1.66:1720|716:dialedDigits=Vicky:h323_ID|terminal|1425_endp
Wed, 26 Jun 2002 16:40:58 +0800 C(1/47/53) &lt;1&gt;
Number of Endpoints: 2
;
</verb></tscreen>
</descrip>

<item><tt/PrintCurrentCalls/, <tt/c/, <tt/!/
<p>Show all current calls using the same ACF syntax as in call establishment.
<descrip>
<tag/Format:/
<tscreen><verb>
CurrentCalls
Call No. # | CallID | Call_Duration | Left_Time
Dialed_Number
ACF|Caller_IP:Port|Caller_EPID|CRV|DestinationInfo|SrcInfo|IsAnswered;
ACF|Callee_IP:Port|Callee_EPID|CRV|DestinationInfo|SrcInfo|IsAnswered;
...
Number of Calls: Current_Call Active: Active_Call From Neighbor: Call_From_Neighbor \
From Parent: Call_From_Parent
;
</verb></tscreen>
<tag/Example:/
<tscreen><verb>
CurrentCalls
Call No. 29 | CallID bd c6 17 ff aa ea 18 10 85 95 44 45 53 54 77 77 | 109 | 491
Dial 0953378875:dialedDigits
ACF|10.0.1.49:1720|4048_CGK1|25263|frank:h323_ID|gunter:h323_ID|false;
ACF|10.1.1.1:1720|4037_CGK1|25263|gunter:h323_ID|frank:h323_ID|true;
Call No. 30 | CallID 70 0e dd c0 9a cf 11 5e 00 01 00 05 5d f9 28 4d | 37 | 563
Dial 0938736860:dialedDigits
ACF|10.0.1.48:1032|4041_CGK1|11896|sue:h323_ID|peter:h323_ID|false;
ACF|10.1.1.1:1720|4037_CGK1|11896|peter:h323_ID|sue:h323_ID|true;
Number of Calls: 2 Active: 2 From Neighbor: 0 From Parent: 0
;
</verb></tscreen>
</descrip>

<item><tt/PrintCurrentCallsVerbose/, <tt/cv/, <tt/!!/
<p>Show details of all current calls.
<descrip>
<tag/Format:/
<tscreen><verb>
CurrentCalls
Call No. # | CallID | Call_Duration | Left_Time
Dialed_Number
ACF|Caller_IP:Port|Caller_EPID|CRV|DestinationInfo|SrcInfo|IsAnswered;
ACF|Callee_IP:Port|Callee_EPID|CRV|DestinationInfo|SrcInfo|IsAnswered;
# Caller_Aliases|Callee_Aliases|Bandwidth|Connected_Time &lt;r&gt;
...
Number of Calls: Current_Call Active: Active_Call From NB: Call_From_Neighbor
;
</verb></tscreen>
<tag/Example:/
<tscreen><verb>
CurrentCalls
Call No. 48 | CallID 7d 5a f1 0a ad ea 18 10 89 16 00 50 fc 3f 0c f5 | 30 | 570
Dial 0225067272:dialedDigits
ACF|10.0.1.200:1720|1448_endp|19618|frank:h323_ID|gunter:h323_ID|false;
ACF|10.0.1.7:1720|1325_endp|19618|gunter:h323_ID|frank:h323_ID|true;
# Sherry:h323_ID|Accel-GW1:h323_ID|200000|Wed, 26 Jun 2002 17:29:55 +0800 &lt;2&gt;
Number of Calls: 1 Active: 1 From NB: 0
;
</verb></tscreen>
</descrip>

<item><tt/Find/, <tt/f/
<p>Find a registered endpoint by an alias or a prefix.
<descrip>
<tag/Format:/
<tscreen><verb>
Find Alias
RCF|IP:Port|Aliases|Terminal_Type|EndpointID
;
</verb></tscreen>
<tag/Example:/
<tscreen><verb>
f 800
RCF|10.1.1.10:1720|800:dialedDigits=Wei:h323_ID|terminal|1289_endp
;
f 801
SoftPBX: alias 801 not found!
</verb></tscreen>
</descrip>

<item><tt/FindVerbose/, <tt/fv/
<p>Find details of a registered endpoint by an alias or a prefix.
<descrip>
<tag/Format:/
<tscreen><verb>
FindVerbose Alias
RCF|IP:Port|Aliases|Terminal_Type|EndpointID
Registration_Time C(Active_Call/Connected_Call/Total_Call) &lt;r&gt;
[Prefixes: ##] (gateway only)
;
</verb></tscreen>
<tag/Example:/
<tscreen><verb>
fv 02
RCF|10.0.1.100:1720|TFN:h323_ID|gateway|4037_CGK1
Wed, 26 Jun 2002 17:47:29 +0800 C(0/84/120) &lt;1&gt;
Prefixes: 02,09
;
</verb></tscreen>
</descrip>

<item><tt/UnregisterIP/
<p>Forcedly unregister an endpoint by IP and call signalling port.
<descrip>
<tag/Format:/
<tscreen><verb>
UnregisterIP IP[:Port]
</verb></tscreen>
<tag/Example:/
<tscreen><verb>
UnregisterIP 10.0.1.31:1720
URQ|10.0.1.31:1032|1326_endp|maintenance;
SoftPBX: Endpoint 10.0.1.31:1720 unregistered!
</verb></tscreen>
</descrip>

<item><tt/UnregisterAlias/
<p>Forcedly unregister an endpoint by one of its aliases.
<descrip>
<tag/Format:/
<tscreen><verb>
UnregisterAlias Alias
</verb></tscreen>
<tag/Example:/
<tscreen><verb>
UnregisterAlias 601
URQ|10.0.1.31:1032|1326_endp|maintenance;
SoftPBX: Endpoint 601 unregistered!
</verb></tscreen>
</descrip>

<item><tt/UnregisterAllEndpoints/
<p>Forcedly unregister all registered endpoints.
<descrip>
<tag/Format:/
<tscreen><verb>
</verb></tscreen>
<tag/Example:/
<tscreen><verb>
UnregisterAllEndpoints
URQ|10.0.1.7:1024|1325_endp|maintenance;
URQ|10.0.1.8:1024|1322_endp|maintenance;
URQ|10.0.1.32:1032|1324_endp|maintenance;
URQ|10.0.1.36:1032|1323_endp|maintenance;
URQ|10.0.1.42:1032|1318_endp|maintenance;
Done
;
</verb></tscreen>
</descrip>

<item><tt/DisconnectCall/
<p>Disconnect a call with given number.
<descrip>
<tag/Format:/
<tscreen><verb>
DisconnectCall Number
</verb></tscreen>
<tag/Example:/
<tscreen><verb>
DisconnectCall 1533
</verb></tscreen>
</descrip>

<item><tt/DisconnectIP/
<p>Disconnect all calls of an endpoint by IP and call signalling port.
<descrip>
<tag/Format:/
<tscreen><verb>
DisconnectIP IP[:Port]
</verb></tscreen>
<tag/Example:/
<tscreen><verb>
DisconnectIP 10.0.1.31:1720
</verb></tscreen>
</descrip>

<item><tt/DisconnectAlias/
<p>Disconnect all calls of an endpoint by one of its aliases.
<descrip>
<tag/Format:/
<tscreen><verb>
DisconnectAlias Alias
</verb></tscreen>
<tag/Example:/
<tscreen><verb>
DisconnectAlias 601
</verb></tscreen>
</descrip>

<item><tt/ClearCalls/
<p>Disconnect all calls on the gatekeeper.

<item><tt/GK/
<p>Show the information of the parent gatekeeper.

<item><tt/Trace/
<p>Set the status interface output trace level. It controls which messages
are sent to this client:
<itemize>
<item><tt/trace 0/ or <tt/trace min/
	<p>Only direct responses to commands and reload notifications.
<item><tt/trace 1/
	<p>CDRs, direct responses to commands and reload notifications.
<item><tt/trace 2/ or <tt/trace max/
	<p>Show all (RAS, CDRs, direct responses to commands, reload notifications, etc).
</itemize>

<item><tt/Debug/
<p>Only used for debug purpose. Options:
<itemize>
<item><tt/trc [+|-|n]/
<p>Show/modify trace level.
<item><tt/cfg SEC PAR/
<p>Read and print a config parameter in a section.
<item><tt/set SEC PAR VAL/
<p>Write a config value parameter in a section.
<item><tt/remove SEC PAR/
<p>Remove a config value parameter in a section.
<item><tt/remove SEC/
<p>Remove a section.
<item><tt/printrm VERBOSE/
<p>Print all removed endpoint records.
</itemize>
<descrip>
<tag/Example:/
<tscreen><verb>
debug trc 3
debug set RoutedMode H245Routed 1
</verb></tscreen>
</descrip>

<item><tt/Who/
<p>Show all people on the status port.

<item><tt/RouteReject/
<p>Terminate this call on a virtual queue.
This command is used as a response to a RouteRequest event (see below).
<descrip>
<tag/Format:/
<tscreen><verb>
RouteReject CallingEndpointID CallRef
</verb></tscreen>
<tag/Example:/
<tscreen><verb>
RouteReject endp_4711 1234
</verb></tscreen>
</descrip>

<item><tt/RouteToAlias/, <tt/rta/
<p>Route this call on a virtual queue to the specified alias.
This command is used as a response to a RouteRequest event (see below).
<descrip>
<tag/Format:/
<tscreen><verb>
RouteToAlias Alias CallingEndpointID CallRef
</verb></tscreen>
<tag/Example:/
<tscreen><verb>
RouteToAlias Suzi endp_4711 1234
</verb></tscreen>
</descrip>

<item><tt/RouteToGateway/, <tt/rtg/
<p>Route this call on a virtual queue to the specified alias and set the destinationSignallAddress.
This command is used as a response to a RouteRequest event (see below).
You can use this command to route calls to out-of-zone gateways or MCUs not registered with the gatekeeper. Make sure that the 'vqueue' and 'explicit' policy is in effect for these calls.
<descrip>
<tag/Format:/
<tscreen><verb>
RouteToGateway Alias IP:Port CallingEndpointID CallRef
</verb></tscreen>
<tag/Example:/
<tscreen><verb>
RouteToGateway Suzi 192.168.0.50 endp_4711 1234
</verb></tscreen>
</descrip>

<item><tt/Exit/, <tt/q/
<p>Quit the status port.

<item><tt/TransferCall/
<p>Transfer an established call from alias A to alias B. When before alias A is talking with alias X, then alias A is talking with alias B after the TransferCall.
<p>Currently this works only with endpoints that properly support
Q.931 Facility messages (so it doesn't work with Netmeeting).
<descrip>
<tag/Format:/
<tscreen><verb>
TransferCall Source-Alias New-Destination-Alias
</verb></tscreen>
<tag/Example:/
<tscreen><verb>
TransferCall Frank Peter
</verb></tscreen>
</descrip>

</itemize>

<sect1>Messages (Reference)
<p>The section describes the messages output to the status interface.

<itemize>
<item><tt/GCF|IP|Aliases|Endpoint_Type;/
<p>The gatekeeper receives a GatekeeperRequest (GRQ) and responds with
a GatekeeperConfirm (GCF).

<item><tt/GRJ|IP|Aliases|Endpoint_Type|RejectReason;/
<p>The gatekeeper receives a GatekeeperRequest (GRQ) and responds with
a GatekeeperReject (GRJ).

<item><tt/RCF|IP:Port|Aliases|Endpoint_Type|EndpointID;/
<p>The gatekeeper receives a RegistrationRequest (RRQ) and responds with
a RegistrationConfirm (RCF).

<item><tt/RRJ|IP|Aliases|Endpoint_Type|RejectReason;/
<p>The gatekeeper receives a RegistrationRequest (RRQ) and responds with
a RegistrationReject (RRJ).

<item><tt/ACF|Caller_IP:Port|Caller_EndpointID|CRV|DestinationInfo|SrcInfo|IsAnswered;/
<p>The gatekeeper receives an AdmissionRequest (ARQ) and responds with
an AdmissionConfirm (ACF).

<item><tt/ARJ|Caller_IP:Port|DestinationInfo|SrcInfo|IsAnswered|RejectReason;/
<p>The gatekeeper receives an AdmissionRequest (ARQ) and responds with
an AdmissionReject (ARJ).

<item><tt/DCF|IP|EndpointID|CRV|DisengageReason;/
<p>The gatekeeper receives a DisengageRequest (DRQ) and responds with
a DisengageConfirm (DCF).

<item><tt/DRJ|IP|EndpointID|CRV|RejectReason;/
<p>The gatekeeper receives a DisengageRequest (DRQ) and responds with
a DisengageReject (DRJ).

<item><tt/LCF|IP|EndpointID|DestinationInfo|SrcInfo;/
<p>The gatekeeper receives a LocationRequest (LRQ) and responds with
a LocationConfirm (LCF).

<item><tt/LRJ|IP|DestinationInfo|SrcInfo|RejectReason;/
<p>The gatekeeper receives a LocationRequest (LRQ) and responds with
a LocationReject (LRJ).

<item><tt/BCF|IP|EndpointID|Bandwidth;/
<p>The gatekeeper receives a BandwidthRequest (BRQ) and responds with
a BandwidthConfirm (BCF).

<item><tt/BRJ|IP|EndpointID|Bandwidth|RejectReason;/
<p>The gatekeeper receives a BandwidthRequest (BRQ) and responds with
a BandwidthReject (BRJ).

<item><tt/UCF|IP|EndpointID;/
<p>The gatekeeper receives an UnregistrationRequest (URQ) and responds with
an UnregistrationConfirm (UCF).

<item><tt/URJ|IP|EndpointID|RejectReason;/
<p>The gatekeeper receives an UnregistrationRequest (URQ) and responds with
an UnregistrationReject (URJ).

<item><tt/IRQ|IP:Port|EndpointID;/
<p>The gatekeeper sends an InfoRequest (IRQ) to an endpoint to query if it
is still alive. The endpoint shall respond with an InfoRequestResponse (IRR)
immediately.

<item><tt/URQ|IP:Port|EndpointID|Reason;/
<p>The gatekeeper sends an UnregistrationRequest (URQ) to an endpoint to
cancel its registration. The endpoint shall respond with
an UnregistrationConfirm (UCF).

<item><tt/CDR|CallNo|CallId|Duration|Starttime|Endtime|CallerIP|CallerEndId|/ \
<newline><tt/CalledIP|CalledEndId|DestinationInfo|SrcInfo|GatekeeperID;/
<p>After a call disconnected, the call detail record is shown (in one line).

<item><tt/RouteRequest|CallerIP:Port|CallerEndpointId|CallRef|VirtualQueue|CallerAlias;/
<p>Request for an external application to route an incomming call on a virtual queue.
This can be done with a RouteToAlias or RouteReject command.

</itemize>


<!----------          FAQ Section          ---------->
<!--
<sect>Frequently Asked Questions
<sect1>General Questions
<p>

<itemize>
<item>What is an H.323 gatekeeper?
<p>
An H.323 gatekeeper controls all H.323 endpoints (like MS Netmeeting)
in his zone. Its most important function is address translation between
symbolic alias addresses and IP addresses. This way you can call
"jan" instead of knowing which IP address he currently works on.

<item>Why should I use a gatekeeper?
<p>
If you currently use a client and are happy with the way it works
there may be no reason to use a gatekeeper. However, if you work in a larger
VoIP setup using symbolic addresses is definitely a great plus.
More importantly the gatekeeper is the key to the management of a VoIP network.

VoIP gateways for example register at the gatekeeper and the gatekeeper
finds the right one for you to use to call a specific number.

A gatekeeper can also manage the bandwidth used by the clients.
Currently we grant all bandwidth requests until a predefined limit is reached.
In the future we could implement a more detailed schema.

<item>What OS do I need to compile / run the gatekeeper?
<p>
Stable version of the gatekeeper run on all platforms supported by the OpenH323
library, which include a wide variety of Unixes such as Linux, FreeBSD,
Solaris, and MS-Windows and others OSes.
However, not all platforms are well-tested.
The developers use Linux and MS-Windows to test the gatekeeper.
Be careful if you're using other OS and report problems if you find bugs.

<item>Can I get a pre-compiled binary?
<p>
There are a few pre-compiled binaries on the project homepage,
but they might not be the most recent version.
See the <ref id="download" name="Download section">.

</itemize>

<sect1>Authentication
<p>
<sect1>Firewall/NAT Issues
<p>
<itemize>
<item>
</itemize>

<sect1>Redundancy
<p>
-->
</article>
