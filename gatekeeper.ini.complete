# File: ~/.pwlib_config/Gatekeeper.ini
# comments may start with # or ;
######################################

## Boolean values.
## Boolean Values are retresented by a case insensitive string
## - "t"..., "y"... or "1" for TRUE
## - all other for FALSE

##
## Params used in  Gatekeeper::Main()
##
## NOTE: This parameters may be loaded at program startup and not influenced by the HUP signal.
[Gatekeeper::Main]
## 'config is present' indicator. Has to be 42.
Fourtytwo=42
# Includes in some RAS-Msgs
Name=OpenH323GK
# overwritten from command line parameter
#Home=195.71.129.69
#TimeToLive=600
# how to print CDRs: use local time or universal coordinates
UseUTCinCDR=TRUE
# how to print CDRs: the format string of the time stamps as defined by PTime
UseCDRFormat=wwwe, dd MMME yyyy hh:mm:ss,uuuu z


[RoutedMode]
GKRouted=1
H245Routed=1
CallSignalPort=1721
CallSignalHandlerNumber=1

[Proxy]
Enable=1
InternalNetwork=10.0.1.0/255.255.255.0,127.0.0.0/8

[Failover]
## Give a list of IP4-Addresses to forward the RRQ to that this
## Gatekeeper receives. Notation: "a.b.c.d:p[,a.b.c.d:p[,...]]" (all numbers)
#Sendto=195.71.129.37:1719
#EndpointIDSuffix=_skeeve
# List of alternate GKs (current maximum: 1)
# Notation: "a.b.c.d:port:regNeeded:prio(1..127)[:gkID]" (a..d,port = numbers)
#AlternateGKs=195.71.129.37:1719:false:120:OpenH323GK2
# when receiving from these IPs, we don't forward the packets to our
# alternate GKs. Insert your alternate GKs here to prevent loops.
# Notation: "a.b.c.d[,a.b.c.d[,...]]" (a..d = numbers)
#SkipForwards=195.71.129.37

##
## This section should not be changed and loaded with the HUP signal at runtime
## because only newly created connections are affected from the change.
## You better restart the gatekeeper after changing something here.
[Gatekeeper::TCP]
UnicastRasPort=1719
MulticastPort=1718
MulticastGroup=224.0.1.41
EndpointSignalPort=9999
#EndpointSignalPort=1720
StatusPort=7000
ListenQueueLength=1024
# [ms], default 1000
SignalReadTimeout=3000
# [ms], default 3000
StatusReadTimeout=5000

##
## Prefixes of e164 numbers for gateways.
## Separate list elements by one of " .,\t".
## @see RasTbl::addPrefixes
## This parameters should consider a HUP signal.
[RasSvr::GWPrefixes]
## Test-Gateways
# 195.71.226.162
#rossi-gt2=80,90
#rossi-gt2=0
# 195.71.226.165
#rossi-gt3=80,90
#rossi-gt3=05241,0521,5241,521
# 195.71.129.254
#ip400-v1=12
#ip400-wi1=0

##
## Options for endpoints.
## For valid attribute names:
## @see GkDatabase::DBAttributeNames
## Attribute "voIPEndpointType" can be: "trunk"|"cpe".
## Separate attributes by ";", key/value pairs by "=" and
## values (if there are more than one for one attribute) by ","
[RasSvr::EndpointOptions]
ep_1=voIPEndpointType=cpe;telephoneNumber=49524670567;voIPlocalAccessCode=0;voIPnationalAccessCode=00;voIPinternationalAccessCode=000;voIPspecialDial=110=49524675123,112=49524675456;plaintextPassword=asdf
gw_1=voIPEndpointType=trunk;voIPCountryCode=49;voIPIpAddress=195.71.226.162

[RasSrv::RRQAuth]
## On a RRQ the h323-alias is queried from this section.
## If there is an entry the endpint is authenticated against the given rules.

## If there is no entry the default action is performed. The default action
## is to confirm the RRQ, unless the parameter "default=reject" is given.
##
## Notation:
##   <authrules> :=  empty  |  <authrule> "&" <authrules>
##   <authrule>  := <authtype> ":" <authparams>
##   <authtype>  := "sigaddr" | "sigip"
##   <autparams> := [!&]*
## The notation and meaning of <authparams> depends on <authtype>:
## - sigaddr: extended regular expression that has to match agains the
##     "PrintOn(ostream)" representation of the signal address of the request.
##     Example: "sigaddr:.*ipAddress .* ip = .* c3 47 e2 a5 .*port = 1720.*"
## - sigip: specialized form of "sigaddr". Write the signalling ip adresse
##     using (commonly used) decimal notation: "byteA.byteB.byteC.byteD:port"
##     Example of the above sigaddr: "sigip:195.71.226.165:1720"
##
## This parameters should consider a HUP signal.

#rossi-gt2=sigaddr:.*ipAddress .* ip = .* c3 47 e2 a2 .*port = 1720.*
#rossi-gt2=sigip:195.71.226.162:1720

#rossi-gt3=sigaddr:.*ipAddress .* ip = .* c3 47 e2 a5 .*port = 1720.*
#rossi-gt3=sigip:195.71.226.165:1720

default=confirm



## The parameter "rule" may be one of the following:
## - "forbid" disallow any connection (default when no rule us given)
## - "allow" allow any connection
## - "explicit" reads the parameter #"<ip>=<value>"# with ip is the ip4-address
##   if the peering client. #<value># is resolved with #Toolkit::AsBool#. If the ip
##   is not listed the param "default" is used.
## - "regex" the #<ip># of the client is matched against the given regular expression.
##   First the ip-rules (like "explicit") are tested. Olny of no such param exists
##   the regex is tried.
##   Example: "regex=^195\.71\.(129|131)\.[0-9]+$"
[GkStatus::Auth]
rule=allow
#rule=deny
#rule=explicit
#rule=regex
# - 195.71.129.*
# - 195.71.100.*
# - 62.52.26.[1-2][0-9][0-9]
#regex=^(195\.71\.(129|100)\.[0-9]+)|(62\.52\.26\.[1-2][0-9][0-9])$
# only used when "rule=explicit"
#default=forbid




##
## Beside other things every number to rewrite has its
## own key/value-line. The implemententation is such that
## all numbers that shell be rewritten have to begin
## with a common prefix given by 'Fastmatch'.
##
## Doc From the code:
## // Do rewrite to #newE164#. Append the suffix too.
## // old:  01901234999
## //               999 Suffix
## //       0190        Fastmatch
## //       01901234    prefix, Config-Rule: 01901234=0521321
## // new:  0521321999
##
## The rewrite-numbers function take care of reloads/a HUP signal.

[RasSvr::RewriteE164]
## Only if an e164 number begins with #Fastmatch# the
## the further rewriting is done. Only one #Fastmatch# can be given.
#Fastmatch=
#0190703100=052418088663
#01903142=0521178260
#5241908601903142=521178260


##
## The GK would send LRQ to its neighbors if the destination of ARQ is unknown.
## A neighbor is selected if its prefix match the destination or
## it has prefix '*'.
## Currently only one prefix is supported.
##
#
# GKID=ip[:port;prefix;password]
#
[RasSvr::Neighbors]
#GK1=203.60.151.5:1719;*;gk1
#GK2=203.60.151.9:1719;02

[RasSvr::LRQFeatures]
#NeighborTimeout=2
#ForwordHopCount=2
#IncludeDestinationInfoInLCF=1

##
## In this section you can put endpoints that don't have RAS support
## or that you don't want to be expired. The records will always
## in GK's registration table.
## However, You can still unregister it via status thread.
##
#
# ip[:port]=alias,alias,...[;prefix,prefix,...]
#
[RasSvr::PermanentEndpoints]
# For gateway
#10.0.1.5=Citron;009,008
# For terminal
#10.0.1.10=798

##
## Authentication mechanism
##
## Syntax:
##   authrule=actions
##
##   <authrule> := SimplePasswordAuth | DBPasswordAuth
##                 | AliasAuth | DBAliasAuth | ...
##   <actions>  := <control>[;<ras>,<ras>,...]
##   <control>  := alternative | optional | required | sufficient
##   <ras>      := GRQ | RRQ | URQ | ARQ | BRQ | DRQ | LRQ | IRQ
##
## Currently supported modules:
##
##   SimplePasswordAuth/
##   DBPasswordAuth      The module checks the tokens or cryptoTokens
##                       fields of RAS message. The tokens should contain
##                       at least generalID and password. For cryptoTokens,
##                       cryptoEPPwdHash tokens hashed by simple MD5 and
##                       nestedcryptoToken tokens hashed by HMAC-SHA1-96
##                       (libssl must be installed!) are supported now.
##                       The ID and password are read from [Password] section
##                       / Database. Support for other backend databases is
##                       easily to add.
##
##   AliasAuth/
##   DBAliasAuth         The IP of an endpoint with given alias should
##                       match a specified pattern. For AliasAuth the pattern
##                       is defined in [RasSrv::RRQAuth] section.
##                       For DBAliasAuth the alias (default: mail attribute)
##                       and IP (default: voIPIpAddress attribute) must be found
##                       in one database entry.
##
## A rule may results in one of the three codes: ok, fail, pass.
##
##   ok         The request is authenticated by this module
##   fail       The authentication fails and should be rejected
##   next       The rule cannot determine the request
##
## There are also four ways to control a rule:
##
##   alternative   If this rule cannot determine the request, it is passed
##                 to next rule. If the answer is positive, the request is
##		   confirmed. If the answer is negative, the request is passed
##		   on to the next rule.
##   optional      If this rule cannot determine the request, it is passed
##                 to next rule. Otherwise, the output determines the
##		   answer, i.e. the request is either confirmed or denied.
##		   In that case, the request is NOT passed on to the next rule.
##   required      The request should be authenticated by this module,
##                 or it would be rejected. The authenticated request would
##                 then be passwd to next rule.
##   sufficient    If the request is authenticated, it is accepted,
##                 or it would be rejected. That is, the rule determines
##                 the fate of the request. No rule should be put after
##                 a sufficient rule, since it won't take effect.
##
##
## "Cannot determine" means the rule is not applicable, e.g:
##    a [Simple|DB]PasswordAuth rule cannot be applied if the request does not contain CryptoTokens
##    a DBAliasAuth cannot be applied if the database entry does not contain the alias field
##
## You can also configure a rule to check only for some particular RAS
## messages. For example, to configure SimplePasswordAuth as a required
## rule to check RRQ, ARQ and LRQ:
## SimplePasswordAuth=required;RRQ,ARQ,LRQ
#
[Gatekeeper::Auth]
#SimplePasswordAuth=optional
#DBPasswordAuth=optional
#AliasAuth=sufficient;RRQ
#DBAliasAuth=sufficient;RRQ
#default=reject
default=allow

##
## Destination analysis mechanism
##  (must be enabled with compiler option WITH_DEST_ANALYSIS_LIST)
##
## Syntax:
##   authrule=actions
##
##   <authrule> := OverlapSendDestAnalysis
##   <actions>  := <control>[;<message>,<message>,...]
##   <control>  := optional | required | sufficient
##   <message>  := ARQ | LRQ
##
## Currently supported modules:
##
##   OverlapSendDestAnalysis  This module checks for incomplete destination
##                            addresses (not fully implemented up to now).
##
## A rule may results in one of the three codes: ok, fail, pass.
## There are also three ways to control a rule: optional, required, sufficient.
## Additionally you can configure a rule to check only for some particular
## messages.
## (see Authentication mechanism for details informations).
#
[Gatekeeper::DestAnalysis]
#OverlapSendDestAnalysis=required;ARQ
#default=reject
default=allow

##
## Use 'make addpasswd' to generate the utility addpasswd
## Usage:
##   addpasswd config userid password
##
#[Password]
#KeyFilled=123
#(id=cwhuang, password=123456)
#cwhuang=UGwUtpy837k=

[MySQLAuth]
#Host=localhost
#Database=billing
#User=cwhuang
#Password=123456
#Table=customer
#IDField=IPN
#PasswordField=Password
#CheckEnableField=Active

[CallTable]
#GenerateNBCDR=TRUE
#GenerateUCCDR=TRUE
#DefaultCallTimeout=21600  // 6hr

# The databases which are used for endpoint configuration.
# The databases are searched for a config in the same order as they
# are listed here.
[Gatekeeper::Databases]
#IniFile=true
#LDAP=true

# the attribute names used for database access, the default is the names
# from the LDAP-VoIP-scheme which is provided within this distribution
[GkDatabase::DBAttributeNames]
#H323ID=mail
#TelephoneNo=telephoneNumber
#FacsimileTelephoneNo=facsimileTelephoneNumber
#H235PassWord=plaintextPassword
#IPAddress=voIPIpAddress
#CountryCode=voIPCountryCode
#EPType=voIPEndpointType
#LocalAccessCode=voIPlocalAccessCode
#NationalAccessCode=voIPnationalAccessCode
#InternationalAccessCode=voIPinternationalAccessCode
#MainTelephoneNo=voIPmainTelephoneNumber
#SubscriberTelephoneNumber=voIPsubscriberTelephoneNumber
#CallingLineIdRestriction=voIPcallingLineIdRestriction
#SpecialDial=voIPspecialDial
#HonorsARJincompleteAddress=voIPhonorsARJincompleteAddress
#PrefixOutgoingBlacklist=voIPprefixOutgoingBlacklist
#PrefixOutgoingWhitelist=voIPprefixOutgoingWhitelist
#PrefixIncomingBlacklist=voIPprefixIncomingBlacklist
#PrefixIncomingWhitelist=voIPprefixIncomingWhitelist
#PrependCallbackAC=voIPprependCallbackAC

# Settings for LDAP access
[GkLDAP::Settings]
#ServerName=ldap
#ServerPort=389
#SearchBaseDN=o=University of Michigan, c=US
#BindUserDN=cn=Babs Jensen,o=University of Michigan, c=US
#BindUserPW=ReallySecretPassword
#sizelimit=0
#timelimit=0

#
# LDAP Cache:
#
# Enable (boolean):    switch caching on/off. Default: off
# MaxMemory (integer): maximum amount of memory used in cache
#                      With internal cache the amount of
#                      results is computed by:
#		       maxresults=MaxMemory/CACHE_AVERAGE_SEARCH_SIZE
#		       CACHE_AVERAGE_SEARCH_SIZE is set in
#                      gk_ldap_interface.h to 10.
# TTL (boolean):       maximum time (in seconds) a cache entry may have.

[LDAPCache]
#Enable=T
#MaxMemory=10000
#TTL=60


# Digit Analysis general section,
[DigitAnalysis::General]
#may specify the override(!) file for the E.164 defined Country Codes,
#in <code>;<descr> syntax
#CountryCodes=cc.dat

# Digit Analysis special section: the keys here have to be E.164 defined
# Country Codes and their value might either be a valid file name or an
# valid function identifier. In case a file is specified, it must
# contain the National Destination Codes (NDC) for that Country Code in
# <code>;<descr> syntax. The function identifier selects a functional
# way to extract the NDC from a given digit sequence.
[DigitAnalysis::Functor]
1=NorthAmericanNumberingPlan
#49=49.dat

# the shared secret for the symetric ciphers used to secure 'plaintext'
# passwords needed for challenge response authentification. LHS the
# cipher's prefix (as used by LDAP for instance); RHS is the base64
# encoded password (shared secret). The actual key used is the MD5
# digest of the password.
[PlaintextPasswd::SharedSecret]
#{BF}=cHc=

# EOF
